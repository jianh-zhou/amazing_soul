## 1 自身面试缺点

- 1 说法语速太快，很多问题本来可以延伸的，但是自己只回答了一个答案，
- 2 很多单词读法错误，甚至读不全
- 很多基础知识都只知道结果，不知道底层原理

## 2 面试问题

### 1 vue 数据通信的几种方式

&emsp;&emsp; <a href="#面试/Vue/vue?id=_6-组件通信方式？">vue 常见的路由通信方式<a/>

### 2 react 纯函数组件和类组件的差异

&emsp;&emsp;1 类组件相对于函数组件有更多的特性，比如 state，还有生命周期<br>
&emsp;&emsp;2 函数组件性能比类组件好，但是在现代浏览器中这种差异很小，<br>
&emsp;&emsp;3 类组件中是有 this 的，函数组件中就不需要使用 this 了，因为 this 是不固定的，所以在某种情况下会出问题（虽然类组件可以通过闭包解决这个问题，然后参数一层层 传递解决，但是这样在参数来自于不同数据源的情况下，就会显得很复杂），这也是纯函数组件的优点。<br>
&emsp;&emsp;4 纯函数组件在想要获取未来的数据时，就是不能直接获取了，需要通过 usRef，而类组件因为 this 的原因，是可以直接获取到最新的数据的<br>
&emsp;&emsp; 函数组件

### 3 跨域总共有哪几种，怎么解决跨域

跨域：跨域其实是浏览器的同源策略导致的，同源策略是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a>文档或者它加载的脚本和另一个源进行交互。它能帮助阻隔恶意文档，减少可能攻击的媒介。
<br>
怎样才算不同源：端口号，协议，域名三个只要有一个不一样，就不满足同源策略，要三个都相等才满足。

##### 1 CORS

&emsp;&emsp;跨域资源共享是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。
&emsp;&emsp;这种跨域一般都是服务器端设置对应的允许跨域的白名单和请求方式，最终解决跨域问题

```js
app.use(async (ctx, next) => {
  ctx.set('Access-Control-Allow-Origin', ctx.headers.origin)
  ctx.set('Access-Control-Allow-Credentials', true)
  ctx.set('Access-Control-Request-Method', 'PUT,POST,GET,DELETE,OPTIONS')
  ctx.set(
    'Access-Control-Allow-Headers',
    'Origin, X-Requested-With, Content-Type, Accept, cc'
  )
  if (ctx.method === 'OPTIONS') {
    ctx.status = 204
    return
  }
  await next()
})
```

##### 2 代理（proxy）

- 正向代理：利用服务器请求不会跨域的特性，让接口和当前站点同域，让本地服务器去请求其他服务器，最后服务器将数据返回给代理服务器，最终代理服务器再将数据返回。
- nginx 反向代理：一台服务器‘代替了'目标服务器，去和客户端进行交互。反向代理可以隐藏真实服务器 ip,提供负载均衡，即指向后端多台服务器中的一台。我们平常的开发项目中使用的代理就是反向代理。

##### 3 JSOP

&emsp;&emsp;JSOP 主要利用了 script 标签请求的时候没有跨域限制实现的，这种方式是一种草根解决跨域的方法，在使用时，仅支持 get 请求方式。使用时，将前端的一个回调函数以 params 的形式传递给后端，后端返回一个带参数的函数字符串给前端，前端接收到响应后，会解析这个字符串，最终就会调用这个函数，函数的参数就是后端要传递给前端的数据。

</br>

### 4 熟悉 node 吗，node 框架 express 和 koa 有什么区别，koa 洋葱模型怎么实现

&emsp;&emsp;<a href="https://juejin.cn/post/6875152985949732872">express 和 koa 的区别</a>
<br>

##### 洋葱模型

&emsp;&emsp;koa 的洋葱模型主要是以 next 函数为分割点，先由外到内执行 request 的逻辑，然后由内到外执行 reponse 的逻辑，通过洋葱模型，将多个中间件直接通信变得更加可行和简单

##### 简易实现 koa 洋葱模型

```js
const middleware = []
function use(fn) {
  middleware.push(fn)
}
use(async (ctx, next) => {
  console.log(111)
  await next()
  console.log(555)
})
use(async (ctx, next) => {
  console.log(222)
  await next()
  console.log(444)
})
use(async (ctx, next) => {
  console.log(333)
})
function compose() {
  return (ctx, next) => {
    dispatch(0)
    function dispatch(i) {
      const fn = middleware[i]
      if (!fn) return
      return fn(ctx, dispatch.bind(null, i + 1))
    }
  }
}
compose()()
```

### 5 知道 vue3 吗？说说 vue3 和 vue2 有哪些区别

### 6 vue2 和 vue3 数据劫持都是怎么实现的，它们的区别是什么，vue3 的数据劫持有哪些好处？

### 7 vue2 和 vue3 的 v-model 是否有区别，都有什么区别？

### 8 谈谈 proxy

### 9 fetch 和 axios 的区别是什么？它们之间有关系吗？

### 10 npm 和 yarn 能同时在项目中使用吗？它们又什么区别

### 11 for in 和 for of 的区别

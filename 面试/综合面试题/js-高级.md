## 1 了解过 WEBPACK 么？WEBPACK 对项目的优化？常见的 LOADER

#### 基础知识

<font size=4>

- 1. entry 入口指示 webpack 以哪个文件为入口开始打包
- 2. output 输出打包后 bundle 输出到哪里去
- 3. loader 加载器 webpack 只能识别 js 和 json 文件，其他文件会直接报错 loader 能帮 webpack 加载它识别不了的模块
- 4. plugins 插件执行任务更加强大的工作（解决 loader 的痛点）
- 5. mode 模式
  - evelopment 开发环境
    能将 ES6 模块化语法编译成浏览器能识别的模块化语法
  - production 生产环境
    能将 ES6 模块化语法编译成浏览器能识别的模块化语法
    压缩 js 代码
    <font size=4>

#### 性能优化方式

##### 开发环境:

- HMR 热模块替换
- css style-loader
- js module.hot.accept

##### 生成环境:

<font size=4>
######   提升打包构建速度

- oneOf 让文件只被一个 loader 处理
- cacheDirectory: true 开启 babel 缓存，让第二次打包速度更快
- dll 将 react 单独打包，之后就不用重复打包 react
- thread-loader 多线程打包，让 babel-loader 任务做的更快（问题:每个线程都有开销 600ms）
- 优化构建后代码性能:
- tree shaking 去除无用/多余 js 代码
- caching 让资源更好的缓存
- code splitting 提取公共代码成单独文件，方便复用
- lazy loading 懒加载 prefetch loading 预加载
- pwa 离线可访问 app

##### 常见 loader:

<font size=4>

- babel-loader
- cache-loader
- css-loader
- less-loader
- sass-loader
- file-loader
- html-loader
- postcss-loader
- style-loader
  （webpack 准备的比较少，自己可以多看一看，比如兼容性配置，hash/contenthash/chunkhash 区别之类的）

## 2 项目做过哪些优化？

1. 减少 http 请求数量
2. 防抖、节流
3. 使用 cdn
4. 重定向少用
5. 图片懒加载
6. 减少 dom 元素数量
7. 减少 dom 操作
8. 使用外部 js 和 css
9. 压缩 js、css、字体、图片等
10. 使用 iconfont
11. 尽量减少 iframe 的使用
12. 避免图片 src 为空
13. 把样式表放在 link 中
14. 把 js 放在页面底部

## 3. 标签加载？

style 标签是异步加载（加载 html 时可以通过加载 style 样式）不会等，解析 html 就会尝试布局、渲染
link 标签是同步加载阻塞渲染（等 link 标签中的资源加载并解析完毕，才可能渲染）

- 使用 style 标签可能会出现闪屏现象。
- 默认使用 link 标签：为了解决闪屏问题

什么时候使用 style：

- 如果样式不在首屏 / 不会一上来显示。就可以用 style

为什么 link 标签放在 head 中？

- 更快发送请求，请求样式资源 -> 更快渲染

js 按照从上到下，顺序执行
js 没有阻塞布局，渲染
js 阻塞 html 解析
为什么 script 放在 body 下面？

- 因为 js 可能要操作 DOM
- js 阻塞 html 解析，导致页面会没有结构

async 异步的：让 js 谁先加载完毕，谁就先执行  
async 既不阻塞 页面渲染 也不阻塞 html 解析

什么时候用 async？ -> 一般放在 head 中，加快解析
如果 js 代码没有依赖关系，用 async
优点：js 加载速度快，不阻塞 html 渲染

defer 和 async 差不多，不同的是 defer 中的 js 必须按照从上到下，顺序执行一般不用

## 4. 浏览器的缓存机制？

浏览器缓存机制有两种，一种为强制缓存，一种为协商缓存

- 强制缓存：浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，不会经过服务器，直接使用缓存
- 协商缓存：第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效,则重新返回最新的数据给浏览器.如果没有失效,返回状态码 304,浏览器使用之前的老资源

## 5. 有几种方式可以实现存储功能，分别有什么优缺点？

一般分为 短暂性存储 和 持久性储存

- 短暂性存储：存在内存中，只在运行时可用
- 持久性储存:
- 浏览器：
  - cookie: 通常用于存储用户身份，登录状态等
  - localStorage / sessionStorage: 长久储存/窗口关闭删除， 体积限制
  - indexDB / WebSQL
- 服务器:
  - 分布式缓存 redis
  - 数据库 mysql

## 6. 为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？

- 解决命名冲突、提供复用性、提高代码可维护性
- 立即执行函数可以实现模块化，不会污染全局作用域

#### 实现模块化

- AMD 和 CMD
- CommonJS
- ES Module

#### 区别

CommonJS 支持动态导入，CommonJS 是同步
导入，CommonJS 在导出时都是值拷贝，ES Module 会编译成 require/exports 来执行的

## 7 说说从输入 URL 到看到页面发生的全过程，越详细越好

1. 首先浏览器主进程接管，开了一个下载线程。

2. 然后进行 HTTP 请求（DNS 查询、IP 寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。

3. 将下载完的内容转交给 Renderer 进程管理。

4. Renderer 进程开始解析 css rule tree 和 dom tree，这两个过程是并行的，所以一般我会把 link 标签放在页面顶部。

5. 解析绘制过程中，当浏览器遇到 link 标签或者 script、img 等标签，浏览器会去下载这些内容，遇到缓存的时候使用缓存，不适用缓存的重新下载资源。

6. css rule tree 和 dom tree 生成完了之后，开始合成 render tree，这个时候浏览器会进行 layout，开始计算每一个节点的位置，然后进行绘制。

7. 绘制结束后，关闭 TCP 连接，过程有四次挥手

## 8 BABEL 的原理

本质就是编译器，当代码转为字符串生成 AST，对 AST 进行转变最后再生成新的代码。

1. 词法分析生成 Token，语法分析生成 AST
2. 遍历 AST，根据插件变换相应的节点
3. 把 AST 转换为代码

## 9 内存泄漏和内存溢出

#### 内存泄漏:

###### 不再用到的内存，没有及时释放

- 意外的全局变量: 无法被回收
- 定时器: 未被正确关闭，导致所引用的外部变量无法被释放
- 事件监听: 没有正确销毁 (低版本浏览器可能出现)
- 闭包: 会导致父级中的变量无法被释放
- dom 引用: dom 元素被删除时，内存中的引用未被正确清空

#### 内存溢出

###### 当程序运行需要的内存超过了剩余的内存时，就抛出内存溢出的错误

- 循环中创建对象

## 10 对面向对象怎么理解？

&emsp;&emsp;对象具体特指的某个事物，具有一定的特性和行为，这个特征和行为也是对应对象中的属性和方法

&emsp;&emsp;因为我们是面向对象（基于对象）进行编程的说到这个面向对象（基于对象），我觉得可以说一下面向对象和面向过程的区别，面向过程他的本意就是凡事都要自己亲力亲为，注重的是一个过程，而面向对象的本意是你可以对 对象 提出需求，根据不同的需求，调用不同的方法，注重的是结果，举个普通例子：你有女朋友和没有女朋友，你没有女朋友的情况下，你烧个菜啥的你得从 0 开始，自己亲力亲为，而在你有女朋友的情况下，你可以对你的对象说我要吃啥菜，你对象会根据你提出的需求来满足你，你只需要最后吃就完事了，过程啥的不用你管。当然，找对象肯定是你自己的事情，也就是说，对象中的属性和方法都需要你自己来定义。

&emsp;&emsp;对象一些特性包含三种，封装、继承、多态，封装的话是（把一个值放在一个变量中，把重复的代码放在一个函数中把多个功能类似的函数放在一个对象中，把多个对象放在多个不同的 js 文件中（模块化）），多态（同一个行为针对不同的对象产生不同的结果），继承（js 原先是没有继承的，后来有了 class，这个 class 也是利用原型的方法来实现继承的），因为原型主要的一个作用就是：数据共享，节省内存，实现继承。

&emsp;&emsp;其实原型和原型的关系也就是我们说的原型链（你构造函数和构造函数的实例对象指向的是同一个原型对象，这个原型对象都是 Object 的实例
对象，Object 的显示原型是最顶层的原型对象，上面就是 null 了，Object 的隐式原型对应着 Function 的显示原型，也就是说，所有对象的原型都是我 Object 的实例，所有构造函数都是我 Function 的实例(Function 的隐式原型对应 Function 的显示原型，Function.prototype.\_\_proto\_\_=== Object.prototype)这样也就形成了互相引用的一个关系，假设 a.b,他会先从作用域链中找 a，然后从 a 原型链中找 b，因为他会先从作用域中找 a，所有可以说下作用域，在说作用域之前，可以先说下执行上下文，因为执行上下文是从属于作用域的，

&emsp;&emsp;执行上下文分为 3 种，全局执行上下文，函数执行上下文，eval 执行上下文（这个 eval 他是把字符串当成代码来解析的，在开发过程中是不用的，所以主要还是说一下前面 2 种），
全局执行上下文他的执行步骤，

1、先确定执行上下文对象为 window，
2、预编译（①.变量提升 ②.函数提升 ③this 赋值）
3、正式执行上下文中的代码。函数执行上下文他的执行步骤，

- 1、当函数被调用的时候，创建函数执行上下文，确定上下文对象
- 2、预编译（①.创建 AO 对象 ②.在里面找变量和形参声明作为 AO 对象的属性名，值为 undefined③.将形参和实参统一 ④ 找函数声明，值赋予函数体）
- 3、正式执行上下文中的代,因为执行上下文是从属于作用域的，全局执行上下文对应着全局作用域，函数执行上下文对应着局部作用域，全局作用域就是变量的可作用范围，局部作用域是在函数声明的时候就决定了，跟函数在哪里调用没有关系，作用域和执行上下文的关系就是：作用域是静态的，执行上下文是动态的，作用域链的定义就是函数内嵌套函数，产生作用域链，其实我觉得和闭包的定义有些类似，只不过闭包不止函数内嵌套函数，还有被嵌套的函数使用了上层函数作用域中的变量，

&emsp;&emsp;闭包的优缺点：优点：延长了局部变量的生命周期：缺点：因为变量会长时间存储在内存中，可能会导致内存泄漏，也就是说闭包能不用就不用，但是在实际开发中是避免不了的，不管是绑定事件，定时器，包括高阶函数都会用到闭包来做一个缓存数据的效果。闭包应该及时释放，把他变成垃圾对象

&emsp;&emsp;所谓的垃圾对象也就是说一个对象没有被引用就是垃圾对象，垃圾对象是有垃圾回收机制的，垃圾回收机制是分为 2 种，之前在 ie9 以及 ie9 以下是用的是引用计数，对对象进行引用就+1，取消引用-1，=0 就会变成垃圾对象被清空掉，

- 优点：及时清除垃圾对象，
- 缺点：对象如果互相引用了，清空不了，可能导致内存泄漏。现在在非 ie 浏览器中使用的是标记清除，从根节点出发，给每一个引用对象打上标记，未打上标记的直接干掉，优点：不会内存泄漏，缺点：深度递归变量，定时的标记定时去清除），

## 11 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验

1. 图片懒加载

2. 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。

3. 如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术

4. 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验

5. 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致

## 12 作用域链

1 作用域链其实就是寻找变量的一个过程

2 在函数定义时,该函数会有一个\[\[scope]]属性,这是底层的属性,不能进行访问,该属性储存了函数定义时的作用域层级关系.在函数调用时,会生成自己的一个执行环境,这个执行环境和之前的\[\[scope]]属性就组合成了作用域链

3 作用域链的顶端就是 window,底端就是当前的执行环境(函数作用域)

4 寻找变量时,会从最底端一直找到最顶端的 window,如果找到就不会再继续找,直到找到 window,如果 window 也没有,则报错

## 13 原型链

原型链就是一个关系,我们在寻找属性或者方法时,会沿着这个关系一级一级找

原型分为显示原型和隐式原型:

- 显示原型指的是函数的 prototype 属性,该属性是一个对象.
- 隐式原型指的是对象中的\_\_proto\_\_属性,这个属性和该对象的构造函数的 prototype 属性指向的是同一个对象.
  - Function 构造函数,是最顶级的函数,所有函数都是它的实例,Function 的\_\_proto\_\_的 prototype 指向的是同一个对象

我们一般会在构造函数的原型上添加方法,实例对象可以直接获取.这样操作可以实现数据共享,节省空间

Vue 组件和 Vue 构造之间的关系就是通过继承实现,通过改变对应函数的 Prototype 属性,最终组件通过原型链的关系,可以使用 Vue 构造函数中的方法

## 14 闭包

闭包简单来说就是嵌套的内部函数,其实也可以理解为包含被引用变量(函数)的对象

闭包的产生必须有三个条件

- 1 函数有嵌套
- 2 内部函数有使用外部函数的数据(变量/函数)
- 3 外部函数必须调用

闭包在函数定义执行完(创建函数对象)就产生了,而不是在函数调用时,在嵌套的内部函变为垃圾对象时会死亡

闭包可以延长局部变量的生命周期,外部函数可以使用函数内部的数据

在 React 的高阶函数中,在绑定事件,而且需要给对应的事件回调函数传递参数,我们使用的就是闭包

闭包也有缺点

- 函数执行完后,函数内部的变量不会及时得到释放,占用内存的时间会变长,容易造成内存泄漏.我们不能滥用闭包,能不同就不用

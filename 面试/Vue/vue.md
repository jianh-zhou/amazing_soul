## 1. V-SHOW 和 V-IF 的区别？

<font size=4>&emsp;&emsp;v-show 是对元素的 display 属性进行操作,最终控制元素是否显示.不管元素是否显示,该元素节点都会一直存在于 dom 结构上

&emsp;&emsp;v-if 是条件渲染,虽然同是控制显示和影藏,但是属性值为 false 的话,该元素之间在 dom 节点中是不存在的.
</font>

## 2. 常用的事件指令有哪些？

<font size=4>

<ul style="font-size:20px">
<li>v-if ,v-else-if,v-else (v-if条件渲染指令,可以单独使用,但是v-else-if和v-else都需要配合v-if使用才可以)</li>
<li>v-show (控制元素的显示与隐藏,本质就是控制display属性)</li>
<li>v-model (双向数据绑定)</li>
<li>v-bind (强制数据绑定,传入动态数据)</li>
<li>v-html、v-text (相当于innerHtml和innerText)</li>
<li>v-for (可以对数据进行遍历,每一个遍历的元素需要加上唯一的key)</li>
<li>v-on (事件指令)</li>
</ul>

## 3. 组件中 DATA 为什么使用函数，不使用对象？什么时候可以使用对象？

<font size=4>
&emsp;&emsp;每一个组件都是vue的实例,组件共享data属性,会有多个组件会被同时使用,我们的data属性只有绑定到一个公共的对象上才能访问到.当data属性值指向同一个引用类型的时候,如果在一个组件实例上改变对应的data数据,那么另外一个组件也会被改变.所以我们应该使用函数,函数内部返回一个对象.每一个实例组件改变只会改变自己组件的data值,不会影响其他组件.

&emsp;&emsp;我们在使用 new Vue() 的时候,我们设置对象或者函数都是可以的,因为 new Vue 的方式是生成一个根组件,该组件不会被调用.也就不存在共享 data 的情况了.我们如果在一个组件只使用一次的时候,也可以使用对象的形式,但是这种做法很冒险.

## 4. KEEP-ALIVE 组件有什么作用？

&emsp;&emsp;我们在组件切换的时候,保存一些组件的状态防止多次渲染,通俗来说就是缓存组件,我们就可以使用 keep-alive 组件包裹对应组件,这个组件拥有两个自己的生命周期钩子函数,分别为 activated 和 deactivated,前者相当于 created,后者相当于 destoryed.如果我们想销毁被包裹的组件,使用 destory 不能被销毁的.我们需要在 deactiavted 钩子函数中调用对应的销毁组件的方法(vm.\$destroy()).命中缓存渲染后会触发 actived 钩子函数

## 5. COMPUTED 和 WATCH 的区别？

&emsp;&emsp;computed 是计算属性,就是通过一些计算后,得到另外的属性.比如我们需要依赖别的属性来获取动态值的时候就可以使用计算属性, (后台管理系统的修改 spu 属性的品台属性时),一般对同步数据进行处理.

&emsp;&emsp;watch 就是监听,我们在监视一个属性,需要进行一些复杂的逻辑操作的时候,我们就可以使用监视.可以进行异步操作

&emsp;&emsp;我们在能不用 watch 的时候就不用,因为如果多个数据影响其中的某一个数据的时候,watch 会被调用多次,影响性能.

## 6. 组件通信方式？

#### 1.Props

&emsp;&emsp;props 可以实现父子组件互相通信，如果父组件和子组件通信的话，使用 v-bind 指令直接向子组件传递一个普通的数据就行，反之如果子组件和父组件进行通信的话，父组件传递一个函数过去，子组件通过调用这个函数，传递参数,实现子向父传递数据.

#### 2.自定义事件

&emsp;&emsp;自定义事件主要还是用作子向父组件传递数据，在父组件中通过 this.$on('事件名',事件的回调)绑定事件,子组件通过this.$emit('事件名',数据)分发事件,达到通信的效果

#### 3.事件总线

&emsp;&emsp;事件总线是利用到自定义事件和 js 原型链的原理来达到的任意组件进行通信，因为每个组件中的 this 都指向组件的实例对象，实例对象的原型又是 Vue 的实例，所以我们可以通过在 Vue 构造函数的显示原型上添加某个字段:如$bus,然后在使用的时候通过this.$bus.$on/this.$bus.\$emit 达到任意组件进行通信的效果

&emsp;&emsp;当调用\$on 方法时,会给将这个回调函数添加到调用这个方法的实例对象上的\_events 属性对象中,将这个添加的事件类型作为对象的一个属性,属性值是一个数组,其中存放着这个事件类型的回调函数,如果添加一个不同的类型,则重新添加一个属性.如果一个类型有多个函数,则是往数组中进行插入

&emsp;&emsp;当调用\$emit 时,就可以从调用这个方法的对象中的\_events 对象中,根据事件的类型,找到对应事件类型的数组,然后全部进行调用

#### 4.Pubsub

&emsp;&emsp;不属于 vue 或者 react，是第三方的一个库，其内部的实现原理其实和自定义事件是差不多的，也是通过订阅和发布的机制来达到任意组件进行通信的效果

&emsp;&emsp;也是在一个都能访问到的对象中,进行一些操作,将回调函数进行存储起来.最终调用实现数据传递

#### 5.Vuex

&emsp;&emsp;vuex 是为 Vue.js 专门开发的状态管理模式,是集中式管理数据的一种通信手段;

&emsp;&emsp;其内部有几大模块，分别是 actions,mutations,getters,state,modules,actions 模块我们一般是用作发送异步请求，然后通过调用 commit(解构 context 获得)函数把请求回来的数据传递给 mutations 中的某一个函数，mutations 模块我们一般是用来直接修改 state 状态数据的，actions 模块中传递过来的数据我们在 mutations 模块中的某一个函数内部可以获取到，然后拿到 这个数据去替换掉 state 中的初始化数据就行了，getters 模块我们一般是用来 返回某个 state 中的数据的，也可以用来动态计算某一个数据进行返回，state 模块我们一般是用来定义初始化数据的，在组件内部我们可以通过 this.\$store.dispatch('某一个 action 函数的名字',数据(可选参数))触发 vuex 的更 新流程，然后通过辅助函数，比如：mapState(需要从 vuex 中单独引入才能使用) 来使用 vuex 中 state 的数据

#### 6. .sync

&emsp;&emsp;.sync 可以用来实现 子组件修改父组件的数据
在父组件中通过 :属性名.sync = 数据
然后在子组件中通过 \$emit(update:属性名,修改后的数据)来实现子组件修改 父组件的数据([详情点击 sync](个人笔记/Vue/20后台管理系统第二天?id=-sync-修饰符.md))

#### 7.作用域插槽

&emsp;&emsp;作用域插槽可以实现父子互相通信，主要是父组件传递标签结构给子组件，在 父组件中也可以访问到子组件传递过来的数据,子组件通过 slot 标签的方式来 进行占位，父组件传递过来的标签结构就显示在占位的地方

###### 其他有用的：还没来得及整理

#### $parent / $children;

&emsp;&emsp;\$parent 在子组件中使用,可以获得唯一的父级组件实例对象,从而对父组件进行传参,或者操作

&emsp;&emsp;\$children 在父组件中使用,可以获取直接的子组件数组,可以使用这个属性获取子组件的数据

&emsp;&emsp;不推荐使用,这只是传递参数的一种应急做法

#### $attrs / $listerens

&emsp;&emsp;\$attrs 可以获取子父组件传递过来的所有属性,但是不包括 props 接收过的,style,class 这三种.如果传过来的是一个动态的对象(v-bind),在使用时,这个对象会被拆分为多个属性

&emsp;&emsp;\$listeners 可以获取父组件传递过来的自定义事件,但是不包括带.native 修饰符的事件

#### provide/inject

&emsp;&emsp;实现父子祖先子孙组件传递数据,provide 是数据的提供者,在父组件中使用.inject 在子孙组件中使用,使用方法和 props 类似

- v-model
- .native
- v-on
- vm.\$set/Vue.set
- 普通插槽/具名插槽
- 自定义指令
- 生命周期要整理
- 数据代理/双向数据绑定的原理
- 路由守卫
- Vue 源码相关的
- Vue3 特性

## 7. 生命周期钩子函数？

- 1. beforeCreate( ) 在这个钩子函数中是获取不到 props 或者 data 中数据的，因为这些数据的初始化都在 initState 中。

- 2. created( ) 在这个钩子函数中已经可以访问到之前不能访问到的数据，但是这时候组件还没有被挂载，所以是看不到的。

- 3. beforeMount( ) 在这个钩子函数中会开始创建虚拟 dom。

- 4.  mounted( ) 在这个钩子函数中会把虚拟 dom 转换成真实 dom，并且渲染数据，组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件挂载完毕，才会执行根组件的挂载钩子。
- 5. beforeUpdate( ) 这个钩子函数在数据更新前调用。
- 6. updated( ) 这个钩子函数在数据更新后调用。
- 8. beforeDestroy( ) 组件卸载之前调用，可以移除事件、定时器、取消未发送成功的 ajax 请求。
- 9. destroyed( ) 所有子组件都销毁完毕后才会执行根组件的 destroyed 钩子函数。卸载组件的方式 this.\$distroy（）
- 9. deactivated( ) keep-alive 独有的生命周期，用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。
- 10. activated( )
- 11. errorCaptured( ) 捕获一个来自子孙组件的错误时被调用,基本用不上，自己可以调试解决。

## 8. MVVM 的理解？和 MVC 区别？

#### 首先先来说下 m，v，vm

- m: model（本地数据和数据库中的数据）
- v: view（用户看到的视图）
- vm: ViewModel（Vue 的实例对象，将视图中的状态和用户的行为分离出一个抽象， 只关心数据和业务的处理，不关心 View 如何处理数据）

#### mvc：

c: controller（控制器)传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。

<a href="#/个人笔记/Vue/MVVM源码执行大概流程和小总结.md">MVVM 源码分析</a>

## 9. 路由的原理？

&emsp;&emsp;通过 history 中的 pushState 和 replaceState 来实现，禁止 a 标签的默认行为,本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面,并且无须刷新页面。目前前端使用的路由就只有两种实现方式：

- hash 模式
- history 模式

###### 区别：

- hash 模式兼容性更好一点，兼容 ie9 以上，history 不考虑 ie
- history 更美观一点
- history 可以使用锚点功能，hash 不可以，因为地址栏多了#

## 10. NEXTTICK？

&emsp;&emsp;nextTick 可以让我们在下次 DOM 更新循环结束之后延迟执行回调，用于获得更新后的 DOM

## 11. 请列举出 3 个 VUE 中常用的生命周期钩子函数?

1.  created（） 2. mounted（） 3. activated（）

## 12. $route和$router 的区别？

- \$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数

- \$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等

## 13. VUE 路由间的参数传递？

- 1. query 传递

     -直接在 url 地址后进行拼接,以?开头,键=值的形式,多个以&分割

     -以对象的形式进行拼接,对象需要 name(定义路由时的对应组件的 name 属性)或者 path(路由地址)中的一个,第二个参数是 query,值是一个对象

- 2. params 传递

     -直接在地址栏后面进行拼接,以\/的形式,\/后面跟一个参数,多个参数就使用多个\/,后面需要在定义路由组件时,使用占位符进行占位.

     -以对象的形式进行传递,对象只能使用 name 属性,第二个参数是 params(对象),传递的参数不会在地址栏中进行拼接,但是只要一刷新页面,传递过来的参数就会消失

- 3. props 传递
     - 1. 布尔模式
     - 2. 对象模式
     - 3. 函数模式

- 4.  meta 传递

  <a href="#/个人笔记/React/5React第5天(Router)?id=react路由-理解">React 路由知识<a/>

## 14 VUE 中响应式原理？

&emsp;&emsp;Vue 的响应式原理是核心是通过 Object.defindeProperty 中的 get 和 set 方法，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher 自动触发重新渲染当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并进行新旧 DOM 对比，然后记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM 树上

## 15. VUE 中实现数据代理的原理？

- data 对象的所有属性的操作(读/写)由 vm 对象来代理操作
  好处: 通过 vm 对象就可以方便的操作 data 中的数据
  实现:proxyData

- 通过 Object.defineProperty(vm, key, {})给 vm 添加与 data 对象相同的属性

- 所有添加的属性都包含 get/set 方法

- 在 get/set 方法中去操作 data 中对应的属性

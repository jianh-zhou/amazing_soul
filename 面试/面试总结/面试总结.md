# HTML 系列

#### 你如何理解 HTML 语义化的 ？

让页面内容结构化,有几个有点

1. 易于用户阅读,样式丢失能让页面呈现清晰的结构
2. 有利于 seo，搜索引擎根据标签上下文关键字的权重
3. 有利于开发和维护,语义化具有可读性,代码更好维护

<header> ：元素描述了文档的头部区域标签导航链接的部分
<section> 标签定义文档的节,章节,页脚,页眉,其他部分
<article> 标签定义独立的内容
<aside>  标签定义页面主区域内容之外的内容(比如则边栏)
<footer> 元素描述了文档的底部区域

### 列举 5 个以上的 H5 事件

- onblur : 失去焦点
- onchange: 当元素改变时运行
- onclick : 单机鼠标时运行
- onfocus : 当获取焦点运行
- onkeydown : 按下按键时运行
- oninput : 用户输入时运行
- onkeyup : 按键松开运行
- onload : 当加载时运行

### meta viewport 是做什么用的，怎么写？

viewport 是指视窗,

meta 有两个属性 name 和 http-equiv

### 你用过哪些 HTML 5 标签

- \<header>
- \<footer>
- \<aside>
- \<nav>
- \<video>、
- \<audio>
- \<canvas>

### H5 是什么？---> 移动端页面

h5 一般指的是开一个 WebView 来加载页面吧

webview 是一种控件，它基于 webkit 引擎，因此具备渲染 web 页面的功能(渲染 web 页面,js 交互调用)

# css 系列

### 两种盒模型

box-sizing: content-box // 标准盒模型： 有内边距 外边距 边框 内容

box-sizing: border-box // 怪异盒模型： 内容 外边距

### 如何水平居中

内联元素 ： text-align

块级元素： margin：0 auto

### 垂直居中

内联元素 ： display：flex align-items：center

​ line-height：设置跟高度一样的 px

### 垂直水平居中几种方式

- 利用定位
- 利用外边距(margin)
- 利用 display：flex 布局
- 使用 tranform,改变 tranlate (x,y)位置

### 块级元素和行内元素,各有什么特点

行内元素 ： a , span , b , img , strong , input , select , lable , em ,button . textarea, selecting

块级元素：div , ul , li , dl , dt ,dd ,p ,h1-h6 , blockquote , form

### 区别：

- 块级元素会独占一行,可以设置宽高,里面可以包含块，行内标签
- 行内元素,如果这一行还有空间,会在一排显示,不可以设置宽高,里面只能嵌套行标签

### css 选择器的优先级权重计算

​ !important > 行内样式> ID 选择器>类选择器>标签>通配符>继承>浏览器默认属性

​ 行内样式(1000) ID 选择器(100) 类选择器伪元素(10) 标签(1)

​ 注意：有时候样式没有设置生效,可能是权重不够,添加权重即可,外层套 div 多设置一层即可

### css 选择器有哪些？哪些属性可以继承

css 选择器 ：id 选择器 类选择器 标签选择器 相邻选择器 子选择器 后代选择器 通配符选择器 属性选择器 伪类选择器

是否可继承

- 可继承 ：font-size font-family color UL Li DL DD DT
- 不可继承 ： border padding margin width height

### css 单位 px ，em，rem 区别

px 像素：绝对单位，像素 px 是相对于屏幕分辨率而言的,谷歌浏览器默认就是 16 px

em 是相对长度单位，相对于当前对象内文本的 font-size 字体尺寸,如果没有设置，则相对于浏览器的字体尺寸，它会继承父级元素的字体大小，不是一个固定的值

rem 是 c3 新增的一个相对单位，它相对的是 html 根元素, 如果需要改动,则需要修改 html 的 font-size(字体大小)

### css 中 link 和 @import 的区别

适用范围不同

- import 可以再网页页面中使用,也可以再 css 文件中使用,可以将多个 css 文件引入到一个 css 文件中,就像我们引入某一个组件库,而 link 只能将 css 文件引入到网页页面中

功能范围不同

- link 属于 XHTML 标签，而 import 是 css 提供的一种方式, link 除了加载 css 外,还可以定义 RSS，定义 rel 链接属性等。但 import 只能加载 css

加载顺序不同

- 当页面要被加载的时候, link 引入的文件会根网页同时加载, 但是 import 不会,必须要等到 页面加载完毕，import 才会加载

兼容性问题

- link 由于是 XHTML 标签,不存在兼容性问题,import 是 css2.1 才提出的 IE5 以上才能识别。

权重区别

- link 引入的样式权重大于 import 引入的样式

### Display ：none 与 visibility ：hidden 的区别

dispaly:none 设置该属性后,该元素下的元素都会隐藏,占据的空间消失

visibility : hidden 设置属性后,元素虽然不可见了,但是依然占据空间的位置

区别

1. visibility 具有继承性,其子元素也会继承此属性
2. display: none 会引起回流(重绘)重排,visibility :hidden 会引起重绘

### Position 的值有哪些,分别有哪些作用

static : 默认值,不脱离文档流

绝对定位：absolute , 绝对定位关键是找对参照物,要称为绝对定位元素的参照物必须满足两个条件

- 参照物和绝对定位必须是包含块与被包含关系
- 该参照物一定有定位属性
- 如果找不到满足条件的父级包含块,就会相对与浏览器进行定位
- 如果设置了绝对定位后,元素会脱离文档流,不在占据空间,左右 margin 为 auto 将会失效,通过上下左右来绝对元素位置

相对定位：relative

- 参照物：元素移动前相对位置
- 注：设置了相对定位,不会脱离文档流, 左右 margin 为 auto 仍然有效

固定定位：fixed

- 参照物：浏览器窗口,会脱离文档流

### 为什么会出现浮动？浮动元素会引起什么问题？如何清除浮动？

浮动定位将元素排除再普通流之外,即元素脱离文档流,按照指定的方向发生移动,

为什么要清除浮动

- 父元素的高度无法被撑开,影响与父元素同级的元素
- 如第一个元素浮动,则该元素之前的元素也需要浮动,否则会影响页面显示的解构解决方法

清除浮动 ：清除浮动的原理就是开启 BFC , 清除浮动不是不让元素浮动,而是清除浮动对父级带来的影响,会造成父级塌陷

- overflow: hidden 给父级设置
- clear 请浮动法：给浮动元素的下边添加一个块元素,书写样式 clear:both
- br 清除浮动,再元素后书写一个 br,br 书写 clear 属性,为 all

### 如何解决 margin 塌陷

第一种情况：两个同级元素,一个设置 margin-bottom 下面的设置 margin-top，那么它们两个的间距会重叠,

解决：添加 overflow：hidden 禁止超出

### 雪碧图(精灵图)： 把网站上需要的图片整合到一张单独的图片中,从而减少网站的 HTTP 请求数量,需要设置再 css 背景图片里面

## less ：less 是一门 CSS 预处理语言,它扩展了 CSS 语言,增加了变量,函数等特性,使得我们维护 CSS 更好

### 伪类和伪元素

伪元素：可以理解伪虚假的元素,虽然会在内容元素的前后插入额外的元素,但并不会再文档中生产,

虽然是虚假的元素,但是再表现上和普通的元素没有区别,设置一些样式都可以

伪类：其核心就是用来选择那些不能够被普通选择器选择的文档之外的元素 a 标签常见的伪类 hover

### img 的 alt title 的异同

alt 是图片加载失败时,显示再网页代替文字, title 是鼠标放在上面显示的文字

alt 是必须要有的,而 title 不是

## 重绘重排

重绘和重排是 DOM 编程中耗能的主要原因之一

重排(回流)：当 render tree 中有一部分或是全部,因为元素的尺寸,布局,隐藏等等引起页面的重新渲染,这个过程称为重排。完成重排后,浏览器会重新渲染受影响的部分,该过程称为重绘

重绘：当再 render tree 中更新的属性只会影响元素的外观，风格,不会影响到布局,浏览器再重新渲染当前的样式,被称为重绘

重排一定会影起重绘,重绘不一定影响重排

## BFC 是什么？

BFC 就是页面上的一个单独的容器,容器里面的子元素不会影响到外面的元素

BFC 称为块格式化上下文创建几种方式：

1.  根元素
2.  float 属性不为 none
3.  position 为 absolute 或 fixed
4.  display 为 inline-block，table-cell， table-caption，
5.  overflow 不为 visible

### css 选择器的优先级

!important-->行内样式-->#id-->.class--->元素和为元素---> \*(通配符) ---> 继承 --->默认

### css 新特性

- transition : 过渡
- transform : 旋转，缩放，移动或者倾斜
- animation: 动画
- gradient : 渐变
- shadow : 阴影
- border-radius: 圆角

### 清除浮动说一下

第一种，伪元素

```js
.clearfix:after{
    content:'';
    display:block;
    clear:both
}
```

第二种给父级添加 overflow：hidden 或者 auto 样式

## flex 布局 ：弹性布局,提供最大的灵活性

### flex 的核心的概念就是容器和轴

### 设置了 Flex 布局以后,子元素的 float ，clear 和 vertical-align 属性将失效

#### flex-direction 属性决定主轴的方向

- row : 主轴为水平方向(x 轴) ，起点再左端
- row-reverse : 主轴为水平方向，起点再右端
- column : 主轴为垂直方向(y 轴)，起点再上沿
- column-reverse : 主轴为垂直方向，起点再下沿

#### flex-wrap 属性：用来换行

- nowrap：不换行
- wrap ：换行，第一行再上方
- wrap-reverse : 换行，第一行再下方

#### justify-content 项目再主轴的对齐方式

- flex-start : 内容象开头这边偏移
- flex-end : 内部象结尾偏移
- center ：内容都居中
- space-between ：内容平均分，左右两边顶端，中间一份
- space-around ： 内容平均分，左右两端有一点空间，中间一份

#### align-items 定义项目再侧轴上如何对齐

- flex-start: 开头对齐
- flex-end : 结尾对齐
- center ： 中间对齐
- baseline : 项目的第一行文字的基线对齐
- stretch(默认值) ： 如果没有设置高度或 auto，将占满整个容器高度

### align-items 和 align-content 区别

align-items 用来一根轴线上,align-content 一根轴线是没有作用的,有多根的轴线才会起作用。一般 align-items 用的比较多

​

## 简述 transform，transition，animation 的作用

transform: 描述了元素的静态样式,本身不会呈现动画效果,可以对元素进行,旋转(rotate),扭曲,缩放和移动 translate

- transition 和 animation 两者都能实现动画效果
- transform 常常配合 transition 和 animation 使用

transition 样式过渡，从一种效果逐渐改变为另一种效果

、animation 动画 由@keyframes 来描述每一帧的样式

# JS

### js 数据类型

基本类型：number boolean undefined null symbol bigint string

引用类型：array object function

## 函数

function ：函数是一段封装的代码,具有一定的功能,可以反复被调用，两种声明方式，字面量声明，函数表达式，new Function 生成函数实例

### arguments 对象 ：是表示函数实参集合，是一个伪数组,(不能使用数组的方法),可以使用下标进行访问,也有 length 属性,可以改变函数的实参个数

### 函数作用域 ：函数的作用域在创建的时候就已经确定了(scope)

- 全局变量：变量声明再整个页面中,都可以进行访问
- 布局变量 ：变量只能再当前函数内部可见,函数外部是不可以访问的

### 执行上下文

在执行 js 代码的时候,会形成一个执行上下文,它在内存中开辟一个空间,js 可执行的代码分为三种,全局代码,函数代码，eval 函数, 会将执行上下文,放入到栈里面,方便管理。

当 js 开始解析的时候,先把全局代码压入到栈中,全局的执行上下文必须要等到全部执行完成后,才被清空,当执行一个函数的时候，会创建一个函数的执行上下文，并且压入到栈中,函数执行完,会将函数从栈清除

### 堆 & 栈

首先,堆，栈数据结构中的内容,堆(链表结构)，栈(栈结构),程序运行的时候按照逻辑分为了堆内存和栈内存

堆 ：堆结构中开辟的内存,比较大,速度比较慢,一般都是由程序员自己用的时候去申请,系统分配,如果要让内存回收,必须手动释放回收 特点: 先进先出

栈：栈结构中开辟的内存,比较小,速度比较快,操作系统分配并且自动回收, 特点:先进后从出

js 中我们所有的内存几乎都是自动分配，自动回收的，js 中封装了垃圾回收机制,栈会自动回收

### 变量提升与函数提升的区别

首先 js 代码指向前引擎会进行预编译,编译期间会将变量声明与函数声明提升到对应的作用域最顶端,函数内声明的变量会提升到函数的最顶端

函数提升：函数提升只用于函数声明式写法,函数表达式不存在函数提升

函数提升的优先级大于变量提升的优先级,所以变量提升再函数提升之下

### 什么是作用域 & 作用域链

什么是作用域 ： 变量起作用的区域范围

作用域的作用 ： 隔离变量(函数外部定义的变量和函数内部定义的变量即使同名也没关系)

作用域的确定时机 ：作用域在进入到全局执行环境或函数执行环境时就已经确定好了

作用域种类 ： 分为全局作用域和局部(函数)作用域

作用域链 ：作用域链是函数执行时创建的,作用域链是由当前函数的作用域+scope 属性中的作用域组成的,函数当前执行的作用域是作用域链的最前端,全局作用域是作用域链的最后端,最后一个。执行环境被销毁,作用域链也会被销毁

### js 变量按照存储方式分为哪些

1. 值类型和引用类型
2. 值类型存储的是值,赋值之后原变量的值不改变
3. 引用类型存储的是地址，赋值之后是把原变量的引用地址赋值给新变量.新变量改变,原来的会跟着改变

### 三种强制类型转换和两个隐式类型转换

强制

- 转化成字符串 toString() String()
- 转换成数字 Number() parseint() parseFloat() +号 乘以 1 都是转为数字类型
- 转换为布尔类型 Boolean()

隐式

- 拼接字符串 var str=' ' + 18
- / % ==

### == 和 === 的区别

== 两个等号：当等号两边的值进行比较值是否相同时, 类型不同时会发生类型的自动转换,转换为相同的类型后再作比较,两个等号只要值相等就可以,类型可以不一样

=== 严格相等,又要判断值是否相等还要判断值的类型是否相等

### 变量对象

每个执行上下文都有三个重要属性：变量对象,作用域链，this

变量对象：变量对象是在每个执行上下文中,被激活了，各种属性才能被访问

作用域链：当查找变量的时候,会从当前上下文的变量对象中查找,如果没有找到,就会从父级执行上下文的变量对象中查找,一直找到全局上下文,这个由局部找到全局执行上下文就形成了作用域链

this ： this 是一个指针,提供一种简明方式隐式传递一个对象引用,让函数接口简单复用，this 永远指向所函数的调用者,如果没有就是指向 window

### this 的四种指向

- 函数如果 new 调用了, this 指向的是新创建的对象
- 是否由 call apply 调用,调用谁,就指向谁
- 函数是否在某个上下文对象调用(隐式绑定),有,那么 this 就绑定在这个上下文对象上
- 如果以上都没有，那就指向 window
- 在箭头函数中的 this 是需要看当前的执行环境,箭头函数 this 和所在环境的 this

### call apply bind

call 和 apply 本质相同,只是传参方式不同,apply 是数组,都是可以改变 this 指向的,函数会自动调用

bind 方法绑定 this 指向返回一个新的函数,不调用不会执行,并且这个新函数的 this 会永久指向绑定的对象,无法改变

### 节流与防抖函数

节流(throttle): 规定的一个单位事件内,只能触发一次函数，如果这个单位事件内触发多次函数，只有一次生效(类似 lol 放技能,技能释放了冷却) 应用场景：发送验证码

防抖(debounce)：事件被触发 n 秒后,如果这 n 秒又被触发,又将重新计时(类似 lol 回城)应用场景：搜索栏

## 对象

什么是对象：js 中,任何值,类型都可以算是对象, 它们都继承了 Object 类型对象,拥有共同的基本属性和方法,对象是无序的集合

定义对象的几种方式：构造函数,对象字面量, Object.create

读取：可以使用 点语法 .name 来进行读取属性,也可以使用 [ ] 语法,中括号里面的属性名必须加上' '字符串

删除: 使用 delete 运算符可以删除对象的属性

对象的遍历：for in 循环,专门用来遍历对象

## 模板字符串里面加上 \xa0 (是 零 不是 O)可以添加空格 nbsp 不可取

```js
;`你再 \xa0 干嘛 ` // 中间就有一个空格了
```

### 基本类型和引用类型：两种值的存储的方式不同,一个是堆,一个栈

基本类型：number string boolean null undefined

基本类型特点：

- 基本类型的值是不可变的
- 不能给基本类型添加属性或方法
- 比较的是值的比较

引用类型值

- 引用类型是变量名是在栈,值和引用地址在堆区储存
- 访问引用类型值的时候,需要通过栈区的地址,引用到堆区的值

引用类型值特点：

- 值是可变的,可以添加属性或者方法
- 值是同时保存在栈和堆区
- 比较的是引用地址的比较

# this 指向

### 怎么判断 this 指向

- 函数是否再 new 中调用,如果有,this 绑定的就是这个新的对象(实例对象)
- 函数是否通过 call ，apply (显示绑定)调用,如果是,this 就绑定到这个指向的对象
- 函数是否再某个上下文对象中调用(隐式绑定),如果有,就将 this 绑定到这个上面
- 如果以上都没有,就默认 window

```js
// 会通过基本包装类型,进行转换
a.call() //window
a.call(null) //window
a.call(undefined) //window
a.call(1) //Number
a.call('') //String
a.call(true) //Boolean
a.call(b) // function b(){}
a.call(obj) //Object
```

# 面向对象的编程,三大特性：封装，继承，多态

### 封装：把客观事物封装成抽象的类，并且类可以可以把自己的方法让可信的对象操作,对不可信的进行信息隐藏

### 继承：子级可以继承父级的数据和方法,子级有了父级的一些方法，称为继承

### 多态：允许不同的类对象发送同一方法，再同一个对象上，产生不同的效果

# 原型，原型链

### js 是动态的弱类型的语言,可以理解为 js 中所有的都是对象,原型也是一个对象,通过原型可以实现对象的属性继承, js 中的对象都包含了一个 prototype 内部属性,这个属性所对应的就是该对象的原型, prototype 作为对象的内部属性,是不能直接访问的,使用 js 引擎提供的 proto 访问

### 何为原型：原型是对象,原型有显示原型(prototype)和隐式原型(proto)都是属于对象

### 为什么要有原型：为了实现数据共享,为了节省内容空间,以及实现原型,构造函数再它的 prototype 上设置方式,即使一万个实例对象访问,也是同一个方法,也是数据共享,也节省了内存

每个函数都有一个 prototype ，即显示原型

每个实例对象都有一个**proto** 可称为隐式原型

### 原型链

- 所以的实例对象都有 proto 属性,它指向的就是原型对象
- 这样通过 proto 属性就形成了一个链的解构----> 原型链
- 当查找对象内部的属性 / 方法时,js 引擎自动沿着这个原型链查找
- 当给对象属性赋值时不会使用原型链，而只是再当前对象中进行操作

### js 中的继承

1. 原型链继承：通过原型将引用类型继承另外一个引用,类型的属性和方法
2. 构造函数继承
3. 组合继承(原型+构造函数)
4. 寄生式继承
5. 寄生组合式继承

### new 操作符

1. 创建一个空对象
2. 将这个空对象的原型,指向构造函数的 prototype 属性
3. 将这个空对象赋值给函数内部的 this 关键字
4. 开始执行构造函数内部的代码

## 数组

什么是数组

- 数组是有序的数据集合
- 每个成员称为元素,每个元素名称称为数组下标
- 里面的值可以为不同的类型

定义数组的方式：构造数组(new Array), 数组字面量

### 什么是类数组(伪数组) ,怎么转化伪真数组

- Array.from() -- ES6
- Array.prototype.slice.call() 改变 this 指向使用 call 方法

### src 和 href 区别

src : 请求外部的资源链接,将内容嵌入到标签中,再 src 请求资源时会将资源下载到文档中,一般 img 图片资源, js 脚本资源

href : 指向某个网络资源所在位置,建立和当前元素(锚点)之间的链接

## Math 对象

Math 是 js 的内置对象，提供一系列的数学常数和数学方法,不需要实例化,自己提供了静态方法

## Date 对象

Date 是 js 内置对象,用来处理日期时间的

# BOM

### bom 是什么：浏览器对象模型,主要用在客户端浏览器的管理

window 对象：BOM 的核心就是 window,它表示浏览器的一个实例。一些常见的方法就是 window 的方法,isNaN( ) **isFinite** `parseInt()`、`parseFloat()` 等方法

全局作用域：只要在全局声明的变量,函数,都会变成 window 的属性和方法

### 常用的超时调用和间歇调用

超时调用：需要使用 window 对象的 **setTimeout()**方法,能够在指定的时间段后执行特定的代码。使用**cleartimeout**取消超时调用

间歇调用：setInterval()方法，能够根据定义的时间执行代码。取消间歇调用**clearInterval**

# DOM

### 什么是 DOM ：DOM 是文档对象模型,加载 html 页面时,web 浏览器会生成一个树形结构,由节点组成的树结构简称为 DOM 树

document 对象是 window 对象的一个属性,当浏览器载入 html 文档时,它就会称为 Document 对象,可以通过它来访问 html 的元素

节点：什么是节点

- 在网页中所有对象和内容都称为节点
- 如 文档，注释，文本，属性，空格

节点种类(常用)：

- document 文档节点
- documentFragment 文档片段节点
- Element 元素节点
- attr 属性节点
- text 文本节点
- comment 注释节点

节点关系：DOM 文档视为一颗树形,称为节点树,关系包括：上下父子关系,相邻兄弟关系

节点类型名称和值：

- childNodes：获取某个元素的所有的子节点
- nodeType ：获取节点的类型
- nodeName：节点名称
- nodeValue：节点的值

### js 事件

DOM 0 级绑定事件方法：元素.on+事件名称=函数

失去和获取焦点：focus 获取焦点事件 blur 失去焦点事件

### 点击事件

- click ：鼠标点击事件
- contextmenu ：鼠标右键事件
- ondblclick ： 鼠标双击事件

### 键盘事件

- onkeydown : 键盘按下
- onkeyup ： 键盘抬起

### 表单事件

- input ：当表单内容改变时触发
- change ：当表单内容改变并且失去焦点时候触发

### 鼠标事件

- mousedown : 鼠标按下
- mouseup : 鼠标抬起
- mousemove : 鼠标移动
- mouseover : 鼠标移入(可以触发事件的冒泡)
- mouseout : 鼠标移出(可以触发事件的冒泡)
- mouseenter : 鼠标移入(不会触发事件的冒泡)
- mouseleave : 鼠标移除(不会触发事件的冒泡)
- 一般常用两个不会触发事件冒泡的

### 滚轮事件

- onscroll : 事件在元素滚动条滚动的时候发生

### 常见的 window 事件

onload 事件：事件会在页面图像加载完成后立即发生

window.onload 事件：当整个文档内容(dom 节点，资源)全部加载完毕,才会执行

### resize 事件

- 窗口重置，resize 事件是在浏览器窗口被重置时触发

### 什么是事件冒泡,怎么工作的,怎么阻止事件冒泡

在一个对象上触发某类事件,如果对象上定义了此事件,那么就会执行这个事件。如果没有定义此事件或者事件返回 true ,那么这个事件会向这个对象的父级对象传播,从里到外,一直到对象的最顶层,都会受到影响

阻止事件冒泡: return false event.preventDefault() event.stopPropagation()

### event 事件对象常用应用

event.preventDefault() 阻止默认行为,阻止 a 链接默认的跳转行为

event.stopPropagation() 阻止冒泡

### 事件三要素

1. 事件源：操作的那个元素,比如 div ,触发的对象
2. 事件：绑定相应的事件,点击,鼠标等
3. 事件处理函数：触发事件后,执行回调函数的内容

### 事件执行过程

先是捕获,在寻找到目标,在执行冒泡

事件捕获过程：当我们点击 text 时,首先是 window->document->body->div->text 这个过程称伪事件捕获

事件冒泡过程: text->div->body->document->window

### dom 事件的级别

DOM 级别一共可以分为四个级别: DOM0-DOM3

DOM 事件分为 3 个级别：

### 事件委托：

也称为事件托管或者事件代理,就是把目标节点的事件绑定到祖先的节点上

优点：优化代码提升性能,把 html 和 js 分离,防止动态添加或删除节点中注册事件的丢失现象

## 线程机制与事件机制

进程与线程

- 进程：程序的一次执行,它占有一片独有的内存空间
- 线程: 进程内的一个独立单元,是程序执行的一个完整流程

特点

- 一个进程中一般至少有运行的线程;主线程
- 一个进程中也可以同时运行多个线程,我们会说程序是多线程运行的
- 一个进程内的数据可以供其中多个线程直接共享
- 多个进程之间数据不能直接共享的

优缺点

多线程 优点：能有效提升 CPU 的利用率 缺点：创建多线程的开销,来回切换开销,状态同步问题

单线程 优点：按照顺序编程简单易懂, 缺点：效率低

js 是单线程运行的

H5 中的 web Workers 可以多线程运行

## js 垃圾回收机制

js 垃圾回收机制为了防止内存泄漏,内存泄漏含义就是当已经不需要某块内存时,这块内存还存在,垃圾回收机制就会找到这些变量,并清除掉它们的内存

### 事件循环 队列 event loop

主线程从'任务队列'中读取事件,这个过程是循环不断的,所有整个的这种运行机制又称为 Event loop(事件循环)

## 什么是任务队列

### 任务队列主要分两种：微任务和宏任务

- 微任务：优先级比宏任务高：常见的有 Promise.then/catch/fanally
- 宏任务：优先级最低：常见的有:setTimeout、setImmediate

先执行同步在微任务,最后宏任务

- 同步任务：在主线程上,排队执行的任务,只有前一个任务执行完毕,才能执行后一个任务
- 异步任务：不进入主线程,而进入'任务队列',等同步执行完毕,在通知主线程,才可以执行的异步任务

### 记住，JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。

## 脚本化 css

offsetWidth 和 offsetHeight

- 使用 offsetWidth 和 offsetHeigth 属性可以获取元素的尺寸(content+padding+border)
- offsetWidth 表示元素在页面中所占用的总宽度,offsetHeight 表示元素在页面中所占用的高度
- offsetWidth 和 offsetHeigth 是获取元素宽高最好的方法
- 当元素隐藏显示时,设置属性 display 的值为 none 时,offsetwidth 和 offsetheigth 返回的值 0

clientWidth 和 clientHeight

- 获取元素可视部分的宽度,既 css 的 content 和 padding 属性的和，不包含任何都滚动的区域和边框

scrollWidth 和 scrollHeight

- 元素包含内容的完全宽度和 padding

offsetLeft 和 offsettop

- offsetleft 和 offsettop 属性返回当前元素的偏移位置
- DOM 标准模式以最近的定位元素(包含块)为参考进行偏移的位置

clientleft 和 clienttop

- 边框的大小

## DOM 进阶

创建节点：

- 使用 document 对象的 creaeElement 方法能够根据参数指定的标签名创建一个新的元素,返回对新元素的引用
- 使用 createElement 方法创建的新元素不会自动添加到文档里,需要使用 appendChild()插入

创建文本节点

- 使用 document 对象的 createTextNode()方法可创建文本节点
- 参数是一个字符串
- 创建的文本节点需要使用 appendChild 等方法插入到元素节点中
- 当然也可以使用 innerHTML 方法给元素节点添加内容

插入节点： appendChild()

- appendChild() 方法可以向当前节点的字节列表末尾添加新的节点

删除节点：removeChild()

- removeChild()方法可以从子节点列表删除某个节点

### 元素内容操作

读取和插入 HTML 字符串

替换 HTML 字符串

- outerHTML 和 innerHTML 功能相同,但是它会包含元素自身

设置属性值

- 使用元素 setAttribute(name,value)方法可以设置元素的属性值

删除属性

- 使用元素的 removeAttribute()方法可以删除指定的属性
- 参数是要删除的属性名

## for in 和 for of 区别

for in 更适合遍历对象,不要使用 for in 去遍历数组

for of 遍历的是数组元素的值，for in 遍历的是数组的下标，for of 遍历的只是数组内的元素，而不包括数组的原型属性 method

总结

- for...of 适用遍历数/数组对象/字符串/map/set 等拥有迭代器对象的集合，不能遍历对象，因为没有迭代对象，与 forEach()不同的是，它可以正确响应 break，continue，和 return 语句
- for...in 可以遍历一个普通的对象，这样也是它的本质工作，for in 会遍历原型以及可枚举属性

### 事件冒泡

事件会从最内层的元素开始发生，一直向上传播，知道 document 对象

p-->div--->body--->html--->document

事件捕获由外向内传播

document-->html-->body-->div--p

### 事件代理

利用事件流的特性，我们可以使用一种叫做事件代理的方法,其实利用的就是事件冒泡的机制

### 阻止事件冒泡和默认事件

event,preventDefault() // 阻止默认事件

event.stopPropagation() // 阻止冒泡

## ES6

新增的方法：

新增声明命令 let 和 const 特点 ：

- let 和 const 都是块级作用域, 不存在变量提升,不可重复声明
- const 定义的是常量 声明之后必须马上赋值,否则会报错，const 声明的简单类型一旦声明就不能再更改,复杂(引用)类型指向的地址不能更改,内部的数据可以更改

##

# Http

### URL 地址格式：schema://host:port/path?query#fragment

- schema:协议，列如 http，https，ftp 等
- host:域名或者 IP 地址
- port ：端口，http 默认端口 80，可以省略
- path：路径，例如 /adc/a/b/c
- query ：查询参数，例如，uname=list&age=12
- fragment：锚点(哈希 Hash)，用于定位页面的某个位置

##

### 几种请求参数方式

- get : 参数在 url 上,浏览器长度有限制,不安全 (只有 get 请求在 url 上,其他都需要配置)
- post:参数不可见,长度不受限制
- put：上传最新内容到指定位置
- delete : 删除请求的 url 所表示资源
- head:不返回响应主体,主要用户客户端查看服务器性能
- options:配置跨域的时候,使用它检验,判断是否对指定的资源有访问权限

## Localstorage,sessionStorage,cookie 的区别

共同点：都是保存在浏览器端，且同源的

1. cookie 数据始终在同源的 http 请求中携带，而 sessionStorage,localstorage 不会自动把数发送给服务器,仅在本地保存
2. 存储大小限制也不同,cookie 数据不能超过 4k,所以 cookie 只适合保存小的数据。另外的两个存储大小大的多,可以达到 5m 更多
3. 数据有效期：
   - sessionStorage:仅在当前浏览器窗口关闭之前有效。
   - localStorage：始终有效,窗口或浏览器关闭也一直存在
   - cookie : 只在设置的 cookie 过期时间之前有效,即使窗口关闭或浏览器关闭
4. 作用域不同
   - sessionStorage：不会进行共享即使是同一个页面
   - localstorage 跟 cookie 在同源窗口都是共享的

##

## ajax 优缺点

优点

- 可以无需刷新页面与服务器端进行通信,请求数据,渲染页面
- 允许你根据用户事件来更新部分页面内容

缺点

- 存在跨域问题
- SEO 不是很友好
- 没有浏览历史,不能回退

## 跨域问题,只有 ajax 请求才会有

同源策略：是浏览器的一种安全策略 协议，端口，域名 不相同请求资源就会跨域

常见的解决跨域的三种问题

JSONP

- 原理：使用 script 标签的 src 属性来实现跨域,通过前端方法作为参数传递到服务器端,然后由服务器端传入参数后在返回,实现服务器端向客户端通信
- 由于使用 script 标签的 src 属性,因此只支持 get 方法

CORS

- 全称是'跨域资源共享',需要在服务器端配置相应的字段,需要和后端人员沟通好,设置为 \* 全部都可以跨域访问即可

PROXY

- 服务器代理解决跨域,我们客户端不能直接请求到相应的服务器,可以自己书写一个服务端,让我们的服务器去请求需要请求的服务器,然后再返回数据给我们的服务器,服务器再返回给我们客户端

## 数据库分类

关系型数据库：代表： MySQL

- 数据存储于硬盘中,每次操作都是 I/O 操作
- 可以使用 SQL 语句(学习成本低)
- 存储数据类型：基本数据类型
- 创建集合之后,集合的字段名不能修改,新增(使用麻烦,但是便于维护)

非关系型数据库：代表： MongoDB

- 数据存再内存中,每隔一段时间,将数据存放在硬盘中
- 不可以使用 SQL 语句
- 存储数据类型：复杂数据类型,就是引用类型
- 创建集合之后,集合的字段名可以任意添加,修改(使用方便,但是不利于维护)

## 路由

### 什么是路由：路由可以理解为一对 key-value ,key -->请求路径,value--> 返回的数据

路由的分类

1. 前端路由
   - 前端路由解析是对应这 js 库(vue-Router,react-Router-DOM)
   - 前端路径不走网络传输层(监视路径的变化,显示不同的组件)
   - 前端路由路径匹配时,返回的是相应的组件
   - 总结：前端路由就是路由路径和路由组件的映射关系
2. 后端路由
   - 后端路由解析是服务器进行解析
   - 后端路由需要前端发送请求触发
   - 后端路由路径匹配时,返回的是数据
   - 总结：后端路由就是路由路径,请求方式与回调函数的映射关系

##

# node

## 中间件本质：函数

作用：

- 添加一些扩展功能
- 处理请求头,响应数据
- 调用下一个中间键

体现形式

- function(req,res,next)
- req-->请求报文对象
- res-->响应报文对象
- next-->放行,负责调用下一个中间件

### express

基于 node 的框架,它最重要的概念就是中间件,核心的 api 为,app.use。express 应用到处都是中间件的使用,请求进来经过一个个中间件函数的处理,再任意一个加工过程都可以完成响应,或者使用 next()放行,进入下一个中间件

# Vue

### Vue 最大的优势是什么

首先,vue 作为目前前端市场需求量较大的框架,它的优势主要体现在,上手容易,一种渐进式的框架,易用，灵活,高效

- 可以进行组件化开发,使代码编写大大减少,更加容易理解
- 最突出的就是 vue 的数据双向绑定(使用了 value 和 input 事件)
- vue 编写出来的界面效果是响应式的,这使在网页各种设备上都能显示好看的效果
- 相比传统的页面通过超链接切换和跳转,vue 使用路由不会刷新页面,单页面应用
- 单页面应用,不用每次请求,就可以使局部页面刷新,大大增加的用户体验
- 它的第三方 ui 组件库节省了很多开发事件,开发效率提高

### MVVM 和 MVC 区别是什么？哪些场景适合

MVVM 模式的理解：M-->Model v-->view (DOM 视图) vm-->Vue 的实例(监听 DOM 和数据绑定操作)

如果数据变化了,视图就会改变,改变视图,数据也会变化,通过 Vue 来链接这种关系,这就是 MVVM 模式

MVC 模式的理解：主要增加了 DOM 操作,M 也是 model 数据模型，V 也是 view 视图,用户看到的页面,C 是 Controller(控制器),通过绑定事件,根据用户的操作,调用 M 和 V 更新数据和视图

总结：MVVM 解决了 MVC 的一些 DOM 操作,让开发更加方便,解决了 MVC 中大量的 DOM 操作,加载速度变慢,影响用户体验,场景：需要使用大量 DOM 操作的适合,就可以使用 MVVM 模式开发,会更加方便,让开发者更加注重于数据

### Vue 生命周期总共分为几个阶段 ： 开始创建-->初始化数据-->编译模板-->挂载 DOM-->更新渲染-->卸载

一共有 11 个回调函数

1. 数据初始化之前和之后
   - beforeCreate
   - created
2. 界面渲染之前和之后
   - beforeMount
   - mounted
3. 界面更新之前和之后
   - beforeUpdate
   - updated
4. 销毁之前和之后
   - beforeDestroy
   - destroyed
5. 缓存组件的切换
   - activated
   - deactivated
6. 子孙组件报错的时候
   - errorCaptured （2.5.0 新增的）

### 第一次页面加载触发哪几个钩子函数

beforeCreate created 初始化数据之前和之后

beforeMount mounted 数据渲染之前和之后

### 组件理解,封装 vue 组件的过程

组件：具有特定功能效果的集合

为什么需要组件开发：首先组件可以提升整个项目的开发效率,能够把页面抽取称多个相应的组件模块,解决的传统开发,效率低,难维护,复用性等问题

1. 分析需求：确定业务需要后,把页面中可以复用的结构，样式功能，单独抽取成一个文件,实现复用 2. 具体步骤：使用 Vue.extend 方法创建一个组件,然后使用 Vue.component 方法注册组件,子组件需要数据,可以在 props 中接受定义,而子组件修改好数据后,使用 $emit 方法,把数据传递给父组件

### vue 的双向数据绑定是什么

vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty(),来劫持各个属性的 setter getter ，再数据变动时发布消息给订阅者,触发相应的监听回调

### Vue / React 书写项目时为什么要在组件中写 key ,作用是什么

首先,在我们日常开发中,我们需要保证某个元素的 key 都是唯一性的，Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 key 的作用主要是为了高效的更新虚拟 DOM

### computed 和 watch 区别

computed 是 vue 中的计算属性,我们平时在模板中书写一些逻辑,代码难以维护,可以使用计算属性来帮助我们完成一些逻辑的书写,这样代码维护起来方便很多，计算属性依赖其他属性计算值,并且它是有缓存的,比 watch 的性能较好,只能当值计算变化才会返回内容

watch 是监听到某个值的变化就会执行相应的回调,我们可以在回调中进行一些逻辑操作

总结：所以一般来说当某个值发生改变,另外一个值也需要发生改变,我们可以使用计算属性。对于监听到值变化需要做一些复杂的业务逻辑的情况可以使用 watch

https://juejin.cn/post/6844903997564796936#heading-12

# Vue-router

### vue-router 路由器：路由的管理工具

### $route 和 $router

- $route 是路由信息对象(跳转的路由对象),每一个路由都会有一个 route 对象,是一个局部对象,包含了 path paramse query hash name 等路由信息传参
- $ router 为 VueRouter 的实例,是一个全局路由对象,包含了路由跳转的方法,钩子函数等

路由：指的是一种映射关系,地址和组件的关系

组件：具有特定功能效果的集合

组件分为路由组件和普通组件

- 路由组件：普通组件通过注册和某个地址发生了联系,这样就形成了路由组件
- 地址：路由地址---> 路由链接地址

我们将普通组件注册成为路由组件后。然后就可以通过声明式路由或者编程式路由来实现单页面应用

声明式路由：router-link(路由链接) 和 router-view(路由视图) 这两个路由上的组件,来展示路由组件的内容。

编程式路由：一般都是绑定点击事件跳转,是通过 js 代码来实现地址和组件的效果展示

一般情况下,声明式路由是用于普通的点击跳转,切换页面。而编程式路由是需要做一些其他的操作,一般是路由传参。传参分为 params query 传参。

params 传参

- 只能使用 name ,不能使用 path
- 参数不会显示再路径上

query

- 带问号,参数会显示再路径上
- name 和 path 都可以进行使用

## vue 单页面 和 多页面 应用

### 单页面应用(SPA)：指只会加载一次资源,后续的交互操作,数据都是通过 router ，ajax 来进行的

优点：有良好的交互体验,首先提升了页面切换体验,用户访问应用页面不会频繁的去切换浏览器页面,避免了页面的重新加载

减轻了服务器的压力,服务器直出数据就可以了

前后端分离互不受影响,前端负责展示页面,后端负责数据存储和计算,不会把前后端的逻辑混杂在一起

缺点

因为它是一次性加载的,有副作用,初次加载耗时相对增多

各个浏览器的版本兼容性不一样,处理兼容的问题

不利于 SEO

### 多页面应用(MPA)

优点

更利于 SEO 优化

更加易于扩展新内容和功能

对大型的应用程序,结构清晰,分类比较明确,像一个可视化地图,用户导航比较方便

缺点

开发和测试比较麻烦,更加耗时,增加开发团队更多的负担

较慢的性能

不容易维护和更新

###

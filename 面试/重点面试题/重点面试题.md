# H5     C 3 新特性

### h5 新特性

语义化标签：

- header ：定义文档头部区域
- footer : 定义了文档的尾部区域
- nav  ： 定义文档的导航
- section ：定义文档中的节
- video ：视频
- audio : 音频
- canvas ：画布

### c 3 新特性

- transition : 过渡
- transform : 旋转,缩放,移动或者倾斜
- animation : 动画
- gradient : 渐变
- shadow : 阴影
- border-radius : 圆角

### css  兼容内核

-moz-: 代表 FireFox 浏览器私有属性

-ms- : 代表 IE 浏览器私有属性

-webkit- : 代表 safari ，chrome 浏览器私有属性

-o- : 代表 opera 浏览器私有属性







### 原型链和原型,继承的方式

首先js是一门动态型的语言,可以理解为js所有的都是对象,原型也是一个对象,通过原型可以实现对象的属性继承,js对象中都会有一个显示原型prototype内部属性,这个属性所对应的就是该对象的原型,prototype作为对象的内部属性,是不能直接访问的,需要通过js引擎提供的proto访问

何为原型：prototype 为显示原型,proto 为隐式原型

原型的作用是,共享资源,节省空间,为了实现资源共享,在prototype 上设置方法,即使无数个实例对象访问,也是只有一个方法,如果让每个单独的实例创建方法,就会浪费很多的空间和资源。利用原型实现的资源共享,同时也实现了节省内存

### 原型链

- 所有的实例对象都有 proto 属性,它指向的就是 prototype (原型对象属性)
- 当查找对象内部的属性,或者方法时,js引擎会自动沿着这个原型链查找
- 当给对象属性赋值时不会使用原型链,而只是在当前对象中进行操作
- 这样就形成了原型链, proto 寻找属性或方法时候

### 继承

1. 原型链继承：通过原型将引用类型继承另外一个引用,类型的属性和方法
2. 钩子函数继承
3. 组合继承(原型+构造函数)
4. 寄生式继承
5. 寄生组合式继承



### 作用域和作用域链

作用域：变量起作用的区域范围

作用域的作用：隔离变量(函数内部定义的变量和函数外部定义的变量即使同名也没关系)

作用域的确定时机：作用域在进入到全局执行环境或函数执行环境时就已经确定好了

作用域的分类：全局作用域和函数(内部)作用域

### 作用域链：

作用域链是函数执行时创建的,作用域链是由当前函数的作用域+scope 属性中的作用域组成的,函数当前执行的作用域是作用域的最前端,全局作用域是作用域链的最后端,最后一个。当前执行环境被销毁时候,作用域链也会被销毁



### 闭包

如何产生闭包：当函数嵌套函数的时候,内部函数访问到外部函数的变量,就形成了闭包

闭包是什么: 闭包就是函数嵌套函数,第二种理解:包含被引用变量的对象

产生闭包的条件：函数嵌套,内部函数引用了外部函数的变量,执行外部函数

常见闭包:react 高阶函数,将函数作为另外一个函数的返回值。将函数作为实参传递给另一个函数调用

闭包的作用：使用函数内部的变量在函数执行完后,仍然存活在内存中(延长了局部变量的生命周期)。让函数外部可以操作到函数内部的数据(变量/方法)

闭包的生命周期：

- 产生：在嵌套函数内部定义使就产生了(不是在调用的时候产生)
- 死亡：在嵌套的内部函数成为垃圾对象时

闭包的应用

1. 具有特定功能的 js 文件
2. 将所有的数据和功能都封装在一个函数内部(私有的)
3. 只向外暴露一个包含 n 个方法的对象或函数
4. 模块的使用者,只需要通过模块暴露对象调用方法来实现对应的功能

闭包的缺点以及解决

缺点

- 函数执行完后,函数内的局部变量没有释放,占用内存时间会变长
- 容易造成内存泄漏

解决

- 能不用闭包就不用
- 及时释放



## promise

### promise 是什么：

promise 是一个异步编程的一种解决方案,也是一个容器,里面保存着未来才会执行的事件(一般都是异步操作,定时器,ajax)。我们在使用 promise 的时候,它是一个对象,可以通过它自身的一些 API ,对各种异步操作都可以进行处理

### promise 功能

当我们在书写代码的时候,遇见回调函数嵌套回调函数,一般称为回调地狱,代码层层嵌套,环环相扣,如果逻辑复杂一下,这样代码很难以维护。

在ES2015标准里.promise 标准化,Promise 对象是一个异步编程的解决方案,可以将异步操作以同步的流程表达出来,避免了层层嵌套的回调函数,让我们的代码整洁,好维护

### pormise  两个特点

1. 对象的状态不受外界影响,Promise 对象代表一个异步操作,有三种状态,pending(进行中),fulfilled(已成功),rejected(已失败),只有等待异步操作结束完,才能知道当前是哪一种状态,任何其他操作都无法改变这个状态。这也是 Promise 的由来,承诺,其他手段无法改变
2. 一旦状态改变,就不会再变,任何时候都可以得到这个结果,Promise 状态改变,就两种情况,从进行中改变,不是成功就是失败,改变后,状态会一直保持这个结果,如果你对后续使用相应的 then catch 回调,会拿到它的结果,这与事件完全不同,事件的特点是,如果你错过了它,再去监听,是拿不到结果的

### promise 使用

Promise对象是一个构造函数,用来生成 promise 的实例

Promise 构造函数接受一个函数作为参数,该函数的两个参数分别的 resolve 和 reject ,它们是两个函数,是由 js 引擎提供的

resolve 是将当前 promise 的 pending 状态改为 resolve 状态,

reject 是将当前 promise 的 pending 状态改为 reject 状态

### promise 自身静态方法有   all，reject ，resolve 等方法,原型上有 then ，catch  方法

- then 方法：它接受两个回调函数作为参数,第一个参数是 promise 对象状态为 resolve 的时候调用,获取成功的值,第二个是 失败的时候调用,获取失败的值
- catch 方法：相当于 then 方法的第二个回调,获取 reject 的返回值

总结：then / catch 方法返回值是一个新的 promise 对象

1. 如果它们接受的是一个 promise 对象,那么它们返回值的promise就是这个promise 对象
2. 如果没有返回 promise 对象,就会新建一个默认成功的 promise 
3. 内部如果报错了,就会返回一个失败的 promise



## css 居中

水平居中

- 内联元素: text-align 
- 块级元素：margin ：0 auto

垂直居中

- 内联元素: 开启 flex 布局	align-items ：center   
- line-height ： 设置和高度一样的 px

### 垂直水平居中的几种方式

- 利用定位
- 利用外边距
- 利用 flex 布局
- 使用 t'ranform 改变 tranlate(x,y) 位置





## flex 布局：弹性布局,提供最大的灵活性

flex 的核心概念就是容器和轴

flex-direction 属性决定主轴的方向

- row ：主轴为水平方向(x轴),起点在左端
- row-reverse ：主轴为水平方向,起点在右端
- column：主轴为垂直方向(y轴),起点在上沿
- column-reverse：主轴为垂直方向,起点在下沿

flex-wrap 属性：换行

- nowrap：不换行  默认
- wrap：换行,第一行在上方
- wrap-reverse：换行，第一行再下方

justify-content 项目再主轴的对齐方式

- flex-start：内容往开头这边偏移
- flex-end ：内容往结尾偏移
- center ：内部居中
- space-between ：内容平均分，左右两边顶端,中间一份
- space-around ：内容平居分,左右两端有一点空间，中间一份

align-items 定义项目再侧轴上如何对齐

- flex-start ：开头对齐
- flex-end: 结尾对齐
- center : 中间对齐
- baseline ：项目的第一行文字的基线对齐
- stretch ：默认值,如果没有设置高度或 auto ,将占满整个容器高度

#### align-content  属性：align-content 只在多根轴线对齐方式,只有一根不起作用

- flex-start : 起点开始对齐,依次按照顺序
- flex-end  :  结束开始对齐.
- center  :     中间对齐 
- stretch  :    默认值，占满整个页面 
- space-between :  两端顶端对齐，中间一份
- space-around :    两端顶端留空间，中间一份



## Vue 的生命周期

### Vue 生命周期总共分为这几个阶段：开始创建--> 初始化数据 --> 编译模板 --> 挂载DOM --> 更新渲染 --> 卸载

一共有 11 个回调函数(钩子)

1. 数据初始化之前和之后
   - beforeCreate
   - created
2. 界面渲染之前和之后
   - beforeMount
   - mounted
3. 界面更新之前和之后
   - beforeUpdate
   - updated
4. 销毁之前和之后
   - beforeDestroy
   - destroyed
5. 缓存组件的切换
   - activated
   - deactivated
6. 子孙组件报错的时候
   - errorCaptured （2.5.0 新增的）



### 第一次页面加载触发哪几个钩子函数

beforeCreate    created  初始化数据之前和之后

beforeMount     mounted  数据渲染之前和之后





## Vue 的响应式原理

通过· Object.defineProperty 去劫持 data 里的属性,将 data 全部属性替换成 getter 和 setter , 配合发布者和订阅者模式,每一个组件都有一个 watcher 实例,当我们对 data 属性赋值和改变时,就会触发 setter方法,setter 就会通知 watcher ,从而使它关联的组件进行重新渲染

### 观察者模式：又称为 发布--订阅者模式

它定义了对象间的一种一或对多的依赖关系,只要当一个对象的状态发生改变时,所有依赖于它的对象都会得到通知并且自动更新,解决了主体对象于观察者之间功能的耦合(两个或两个以上有相关联系的),即一个对象状态改变给其他对象通知的问题





## Vue / React 虚拟 DOM 于唯一  key 值

虚拟DOM : 虚拟DOM是一个对象,用来储存真实DOM信息

虚拟DOM 可以提高浏览器的渲染速度,比起操作 JS 对象,操作真实DOM消耗的性能较多,所有在Vue中不建议直接操作DOM的

实现步骤

1. 在页面首次渲染时,将需要渲染的数据全部都加载到虚拟DOM中,而后,
2. 在数据变化时,额外的生成一颗虚拟DOM树
3. 通过 Diff 算法对比修改的部分,而后将修改部分渲染到真实的DOM树中
4. 释放内存

### key 值用处

首先,在 Vue 中,存在一个 DOM 复用机制,会尽量回收DOM元素进行复用,但是复用有时候会造成一些Bug,在加了 key 值后,元素就会有了一个唯一的标识,复用机制不会附带 key 值的元素,解决了DOM复用机制的问题

key 值一般来说,最好是 独一无二 的

虚拟 DOM 在使用 Diff 算法进行对比时,key 值存在,可以更高效更迅速



## Vue  MvvM 模式理解

M-Model 层：值在 Vue 中 data，computed , methods 中的数据

V-View : 在 Vue 中绑定 dom 视图

VM - 值 Vue 中实例的 vm 对象

如果数据发生变化,视图就会改变,反之,视图发生变化,数据也会跟着发生变化。就是通过 Vue 来链接这种关系,也称为 MvvM 的模式







## Vue 的组件通信方式

首先回答,组件通信有很多,看是父子组件通信,兄弟组件通信,祖孙组件通信,可以根据不同的组件通信,来选择不同的通信方式

### 父子组件通信几种

- props ：父子组件通信,可以传递属性和回调事件
- 自定义事件：父子组件通信
- 插槽：父子组件通信

### 任意组件通信

- 事件总线($bus) : 任意组件通信
- 消息订阅(PubSub) : 任意组件通信,这个属于单独的插件(小程序,react)都可以使用,不属于 vue
- vuex ：任意组件通信,之前做项目基本都是用这个(状态管理工具)





### Vue 路由懒加载：就是用到时再加载

懒加载主要作用是将路由对应的组件打包成一个个 js 代码块,只有再这个路由被访问到的时候才加载对应的组件。最主要的作用就是提高性能,页面渲染的更快,用户感觉体验比较好。也是一种性能优化的方式









## keep-alive 

### keep-alive 是vue-router的组件

首先 keep-alive 是实现组件缓存的方式 

我们vue组件化开发中,我们会把整个项目拆分很多业务组件。组件多了,那么就会有一个问题,那就是组件之间来回切换的问题。vue 中有动态组件的概念,它能够帮助我们开发实现组件之间的切换,但是面对需要频繁的切换的时候。vue 中每次组件切换组件的实例都是需要重新创建的,这样频率很高,性能不是很好。所以我们需要使用 vue 内置的组件 <keep-alive>

将需要缓存的组件放置到 keep-alive  组件中,会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染

keep-alive 有两个生命周期函数 

- avtivated ：再组件第一次渲染时会被调用,之前再每次缓存组件被激活调用
- deactivated ：组件被停用(销毁)时调用





## 性能优化

1. 雪碧图：就是把很多小图片制作成一个大图片,然后作为背景图使用,使用定位即可，这样可以减少 http 的请求
2. 图片的懒加载
3. 节流,防抖函数
4. 避免重绘和回流
# vue的异步请求和路由器组件

## Element-ui组件的使用

### 1 npm安装

- npm i element-ui -s

### 2 引入

- import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';

### 3 Vue使用此插件

- Vue.use(ElementUI)

### 4 直接使用

- <el-button type="success">成功按钮</el-button>
- Element-UI自定义的标签,以el开头

### 注意

- 1  在2,3步骤都是在main.js中引入的
- 2  使用的时候是在对应组件template标签中使用

## vue-resource 异步请求操作

### 1 npm安装

- npm i vue-resource 

### 2 引入声明使用插件

- import  VueResource from 'vue-resource'
- Vue.use(VueResource)

### 3 直接使用

- 在使用该插件后,所有vue组件都可以使用$http方法,然后通过get或者其他方法进行异步请求
- this.$http.get(url)

	- 返回一个promise对象,可以通过使用then方法获取到请求的数据

### 可以使用生命周期回调函数mounted,来使用async和await来实现异步请求

## axios

### 1 在使用该axios的组件中引入axios插件

### 2 直接使用该方法发送异步请求,得到数据

## 获取github用户信息的案例

### 1 使用全局事件总线让兄弟组件进行通信,通过在Vue构造函数添加一个属性,属性值为Vue的实例对象,最终所有组件都可以该属性上的方法从而可以互相进行通信

### 2 正常来说template标签中只能有一个跟标签,但是也可以有多个,使用条件渲染指令,最终只有一个标签满足条件即可

## 路由器组件

### 相关概念

- vue-router

	- 路由的管理工具

- 路由

	- 指的是一种关系,组件和地址之间的映射关系

- 路由组件

	- 普通组件通过注册和地址发生关系,该组件称之为路由组件

- 地址

	- 路由地址--->路由链接地址

- 路由的分类

	- 声明式路由

		- 路由链接和路由视图组成

	- 编程式路由

		- 通过js代码实现地址和视图的转换

### 1 在文件中引入路由器插件,然后利用Vue的use方法使用该插件,最后将路由器实例对象暴露出去,

- 路由器实例对象配置(就是当前实例对象的配置对象)

	- mode属性

		- 设置为'history'可以去掉地址的#符号,也就是使用history模式,默认是hash模式

	- routes

		- 值是一个数组,里面是注册路由的多个集合

	- 注册路由集合的属性

		- path:'/home'

			- 当前的路由地址

		- component:Home

			- 注册Home这一个组件

### 2 在main.js文件中引入暴露的路由器实例对象

- 在Vue实例对象的配置中.注册路由器
- router:router(router)

### 3 声明式路由注册

- 1  在要使用路由组件的组件中一路由链接的形式使用

	- <router-link to="/home">Home</ router-link>
	- 路由链接相当于就是a标签,最终都是转换为a标签,to属性就是要跳转的路由链接,该链接都是相当于地址的根目录

- 2 使用路由视图标签

	- <router-view></router-view>
	- 使用这个标签对应的路由组件才会在页面进行渲染展示

- 使用时,需要两个配合在一起使用,在一个组件中,就算有多个路由链接标签,路由器视图标签只要使用一次就可以,

## 路由器组件练习

### 1 引入对应的vue-router插件等其他,使用该组件,实例化路由器实例对象暴露,并对其进行配置

- 1 由于注册路由器组件的数量过多,我们创建一个单独的文件来将注册路由器组件的数组,最终暴露出去
- 2 如果路由器组件是在一个路由器组件下使用的,我们在注册该路由器组件时,我们需要把该路由器组件放到它的上一级路由器组件注册配置对象的后面,使用children属性,该属性值是一个数组.可以用来注册多个子路由组件,
- 3 设置重定向操作,就是当跳转到根路径时,直接跳到对应的路由器组件,也是一个对象

	- path属性

		- path:'/'

	- redirect属性

		- 对应的路由器组件的路由地址
		- 重定向

### 2 main.js文件中引入该VueRouter实例对象,并对其进行注册,以便所有组件都能使用

### 3 在对应的组件中使用路由器链接和路由视图

### 4 使用路由器组件传递参数的情况

- 获取params属性

	- this.$route.params
	- 组件实例对象下的$route属性

- params方式

	- 在注册路由器组件时,利用/:id设置
	- 在使用时,将:id传入一个参数,最后这个参数就能跟在/后面,进行跳转使用

- 在传入参数时,因为每次要传入的参数不一样,所以我们的这个$route属性是需要监视的,将最后的拿到的参数再进行使用,如果只使用mounted生命周期回调函数来使用,它只适合第一次使用该组件时使用,因为该函数只渲染一次,后面如果想改变参数进行传递就么有效果,所以我们需要使用watch对$route进行监视
- 不管在哪个组件,都可以获取到当前的params参数

### $route

- 路由信息对象
- 获取的是路由跳转过后传递的一些参数对象

	- params

### $router

- 该对象上有一些push,replace等方法

## 编程式路由

### 通过js代码实现路由跳转

### 通过事件,触发回调函数,调用组件实例对象上的$router属性的上的一些方法,参数就是要跳转的路由器地址,最终实现路由组件的跳转

### this.$router.push(`/home/message/detail/${id}`)

- 该方法和router-linlk一样

### this.$router.replace(`/home/message/detail/${id}`)

- 该方法就是相当于没有历史记录,
- 在不使用返回上一个链接跳转的操作时,和push方法一样,但是它是相当于没有历史记录,如果向上一个链接跳转,他会跳到当前路由地址最开始传递参数的情况

### 也可以直接当做事件的回调函数

- @click="$touter.back()"
- 该方法时返回上一次路由跳转
- 针对replace,该方法直接跳转到最开始的路由链接
- 针对router-link和push会跳转到上一次的路由链接

## 缓存路由组件

### 有keep-alive标签包裹住的路由视图标签,则该组件就为缓存路由组件

### 该路由组件使用传递的属性,可以直接在对应的路由组件标签中使用props方法接收,并且使用

## 错误

### 1 实例化路由对象的配置时,mode属性的值是要加引号的

- mode:'history'

### 2 引入vue时,名字是首字母大写,组件都是小写

- import Vue from 'vue'

### 3 在引入路由组件注册的数组时,只要名字为routes时,路由实例对象的配置就可以直接简写为routes,因为它只有routes属性

### 4 在Vue实例对象的配置中,需要进行全局注册路由器对象,router:router(简写为router)

### 5 在使用监视watch属性时,监视的方法名字就是要监视的对象,方法传入的参数就是当前监视的对象


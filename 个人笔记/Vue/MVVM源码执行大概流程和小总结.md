## MVVM源码执行大概流程和小总结

#### MVVM源码执行大概流程

##### 1 实例化VMMV构造函数,得到vm实例对象(后续vm就代表该实例对象),在实例化时,传入配置对象作为参数

##### 2 进入VMMV构造函数体中,判断配置对象是否存在,如果不存在,则配置为空对象,否则就是该对象,将该对象赋值为一个变量data,并且给该对象添加一个_data属性,值也就是传入的配置对象

##### 3 利用Object.keys( )得到data变量所有的属性值,对这个数组进行遍历.在遍历时,调用_proxyData方法,该方法内部进行操作,实例Object.defineProperty( )为vm实例对象添加属性..     该方法内部会有get和set方法.当这两个方法触发时,都会执行后续的另外一个对象的get和set方法(也就是第5步)   ,      此时就实现了数据代理   在执行完这个对应的数据代理完之后,会执行该构造函数中的observe方法,该方法会传入的config(配置对象)和vm

##### 4 执行observe函数时,该函数核心就是判断传入的第一个参数是否是一个对象,如果不是对象.则直接return.否则返回一个Observer实例对象,并把执行该函数时传入的第一个参数作为参数传入到构造函数中.

##### 5 为Observer实例对象(obs)添加两个属性,一个data属性保存最开始传入进来的配置对象(config),第二个参数是执行walk方法,config做参数传入,在执行walk方法时,会使用Object.keys( )方法遍历所有的key值,然后在该回调函数中进行调用函数.在调用的过程中,会最终为配置对象添加使用Object.defineProperty( ),为其添加get和set方法, get和set方法内部在执行时,都会调用dep对象中的一些方法

##### 6 observe方法执行完毕,回到VMVM函数中,为vm实例对象添加一个$compile属性,该属性是一个Compile实例对象,该构造函数传入两个参数,一个就是容器对象,一个就是vm实例对象

##### 7 进入Compile构造函数,为Compile实例对象 ( com)添加两个属性,$vm和$el属性,这两个属性就是最开始传入的参数vm和el( 容器对象) ,执行一个判断,是否有容器对象,如果有则为com添加一个$fragment(文档碎片对象)属性,该属性的值就是将容器对象的所有子节点全部剪切到这个文档碎片对象中.

##### 8 执行init方法,然后执行compileElement方法,将文档碎片对象作为参数传入.获取节点的文本内容,定义一个正则表达式,用来检测是否是插值语法的格式,遍历文档碎片对象中的所有子节点,判断这个节点的内型

- 如果这个字节点是元素.则执行compile函数.函数内部获取该元素所有的属性,利用call方法,将其转换为一个数组.遍历其中的所有属性,判断该属性是不是一个指令(v-开头),如果是则去掉v-.进入一个判断,判断该指令是否为事件指令

	- 如果是事件指令

		- 执行compileUtil中的eventHandler方法.该方法同过一系列操作,利用addEventListener方法为该节点绑定事件,

	- 如果是普通指令,跟据指令的类型执行compileUtil中不同的方法,这些方法都会调用bind方法

		- text

			- 执行bind方法

		- html

			- 执行bind方法

		- class

			- 执行bind方法

		- model

			- 执行bind方法

- 如果这个节点是文本,而且符合插值语法

	- 执行对应的compileText方法,
	- 插值语法是在属于一个节点,会和其他普通指令不一样,他会跳过它们中间的一写步骤,但最终都会执行对应的bind方法,执行对应的代码

##### 9 在执行完对应的updater方法后,会返回到compile方法中,删除当前的指令属性,然后init方法执行完毕,最终执行Compile构造函数中的代码,将文档碎片对象插入到对应的容器中,渲染结果

## VMMV源码总结及注意点

##### 源码思路

- 封装多次.层层调用.进入对应的构造函数中,都会将对应的参数进行保存起来
- 通过在Watcher实例对象上的depIds绑定dep对象,在dep对象上的subs属性上绑定对应的watcher对象,两个对象之间互相绑定,达到互相修改的目的
- 在执行代码的过程中.只要访问和设置属性的值,都会进入VMMV的get和set,这里面的get和set也会进入对应的Observer的get和set中,通过这个get和set中,会调用对应的dep中的方法,会执行对应的代码,watcher和dep的再次互相绑定
- 在执行代码时,使用了很多次遍历,在所以到最后,会有很多层的循环以及循环套循环
- 使用了很多递归和闭包

##### dep和watcher

- dep对应属性
- watcher对应一个表达式
- dep和watcher之间的关系

	- 一对一

		- 一个属性对应一个表达式
		- 就是对应的属性在html中只有用到一次

	- 一对多

		- 一个属性对应多个表达式
		- 就是一个属性在html中使用过多次

	- 多对一

		- 多个属性对应一个表达式
		- 属性值为一个属性中的对象的值,在访问时,需要访问多次,所有是多个属性对应一个表达式

	- 多对多

		- 多个属性对应多个表达式
		- html中使用了多个不同的表达式,也有多个不同的属性

##### 关键点

- 1 两次使用Object.defineProperty( )方法添加属性中的get和set方法.
- 2 dep和watcher的互相绑定
- 3 文档碎片对象(虚拟DOM)


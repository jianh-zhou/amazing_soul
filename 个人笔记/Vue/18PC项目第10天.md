# 17PC项目第10天

## 路由守卫(导航守卫)

### 路由守卫的概念

- 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。
- 就是现在跳转到这个路由的一些限制条件,

### 路由守卫的分类

- 全局守卫

	- 全局前置守卫 router.beforeEach

		- 是一个方法,参数是一个回调函数,回调函数有3个参数
		- 参数回调函数的参数

			- 参数1  to

				- 要跳转到的路由地址的路由信息对象

			- 参数2 from 

				- 即将要跳转的当前路由信息对象

			- 参数3 next

				- 是一个方法,只有有该方法,才会起到一定的作用,如果没有该方法,所有路由都会禁止跳转

					- 有参数

						- 参数就是要跳转到的对应路由

					- 没有参数

						- 没有守卫,直接放行

	- 全局解析守卫 router.beforeResolve

		- 和全局前置守卫类似,区别是在导航确认之前,同时所有组件内守卫和异步路由组件被解析后,解析守卫才会被调用

	- 全局后置钩子

		- 注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：

- 组件内守卫

	- beforeRouteEnter 

		-  是一个钩子,和生命周期回调函数基级别相同
		- 参数 to from  next
		-  函数内部不能直接使用this(实例对象)因为,该函数在执行时,组件还没有被实例化,所以this是不存在的
		- 可以调用next方法.next方法传递一个回调函数作为参数,该回调函数的参数就是当前实例对象,在有该实例对象后,会调用这个回调函数,执行回调函数中的代码,实现路由守卫的操作
		- 唯一一个可以给next方法传递回调函数的守卫

	- beforeRouteUpdate 也是一个回调钩子,和生命周期回调函数的级别一样
	- beforeRouteLeave 也是一个回调钩子,和生命周期回调函数的级别一样

		- 这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。

- 路由独享守卫

	- 1 在注册路由组件的时候配置
	- 2 添加一个beforeEnter属性,值是一个回调函数,回调函数的参数是to,from,next
	- 3 在回调函数内部进行操作,设置路由守卫
	- 4 只有访问这个路由的时候,才会执行这个回调函数

## 路由组件的路由守卫的配置

### 1  在为进行登录的时候,使用全局前置守卫进行限制center,pay,trade对应组件及相关组件的跳转

- 1 引入对应的store对象,
- 2 获取要跳转的目标路由

	- const targetPath=to.path

- 3 定义一个数组,将所有需要守卫的路径存放在里面
- 4 判断目标路由是否含是以数组中的路由包含或者开头的

	- 1 使用find方法遍历数组,在回调函数中,使用数组的indexOf方法,判断当前的路由是否包含数组中元素,如果包含,最终就会返回数组中的一个元素,最终进入判断

- 5 如果满足条件,则再次进行判断,判断用户当前是否登录过,使用store对象中,获取对应的token值,
- 6 如果登录过,则直接调用next()
- 7 如果没有登录过,则跳转到登录界面 next('/login)
- 8 如果不是请求这些路由,则直接全部放行 next( )

### 2 实现在登录的情况下不能进行登录,使用组件内守卫beforeRouteEach

- 1 获取token判断当前的登录情况
- 2 如果登录过,则直接跳转到主页 next('/')
- 3 否则跳转到登录组件

### 3 只有skuId和skuNum和skuInfo数据都存在的情况下,才能进入到/addsuccess界面,使用路由独享守卫beforeEnter

- 1 根据参数to获取对应的skuId和skuNum,读取浏览器缓存获取skuInfo
- 2 判断三个参数是否都存在
- 3 如果都存在,则放行 next( )
- 4 如果不存在,则跳转到之前的界面 next( from.path)

### 4. 只有从/shopcart 才能进入到/trade

### 5. 只有从/trade 才能进入到/pay

### 6. 只有从/pay 才能进入到/paysuccess

### 7 如果我访问的是/center,但是没有登录,先跳转到登录界面,登录成功后自动的进入到/center中

- 
- 1 在设置访问center路由条件的时候,拼接一个参数,

	- next('/login?redirect'+targetPath)
	- 如果有传递redirect参数,则会登录后跳转到对应的订单组件

- 2 点击登录的时候,在跳转到主页的之前,通过路由信息对象的query参数,获取redirect

	- const {redirect} = this.$route.query
	-   this.$router.replace(redirect||'/')

		- 如果有redirect参数,则跳转到订单页面,否则跳转到主页

### 8 如果退出,则直接进入到首页

- 在头部组件中,点击退出的按钮上,在执行对应的操作后.使用编程式路由直接跳转到主页

	-  this.$router.replace('/')

## 支付页面的完善

### element-ui 插件

-  作用

	- 当前项目中用来弹出信息的提示和弹出对话框

- 1 安装 

	- npm install element-ui

- 2 文件babelConfig文件中进行配置
- 3 在utils中新建一个element.js文件,里面书写关于element.js 按需引入的代码
- 4 在main.js 引入该文件,相当于把这个文件的内容在main.js中

	- import './utils/elements'

### qrcode 插件

- 作用,

	- 使用该插件提供的一些方法,产生二维码
	- 安装

		- npm install qrcode

### 27 支付界面的支付

- 1 为(立即支付)按钮绑定一个事件,事件的回调函数为pay
- 2 定义事件的对应方法,
- 3 调用对应的QRCode.toDataURL(this.payInfo.codeUrl).返回一个promise对象,调用对应的then方法(1) 和catch方法,then方法是二维码生成成功的回调,catch是二维码生成失败的回调
- 4 在第一个then方法,使用this.$alert方法,通过参考文档对齐进行配置,弹出一个微信二维码的弹出提示框.该方法返回一个promise对象,使用对应的then(2)和catch方法
- 5在第二个then方法中,进行相关的操作,进行路由跳转,在第二个catch方法中,弹出对应的警告框
- 6 在第一个then方法里面定义一个计时器,用来请求支付的状态,因为只有一直请求,才能获取到支付的状态,
- 7 在计时器的回调函数中,调用对应的支付状态的api接口函数,返回一个promise,调用对应的then方法,和catch方法,then方法是支付成功执行的,catch是支付失败的回调

## 图片的懒加载

### 1 下载安装对应的插件 

- npm install  vue-lazyload

### 2 在main.js文件中引入该插件

- import VueLazyload from 'vue-lazyload'

### 3 在main.js中引入对应的图片资源

- import loading from './assets/loading.gif'

### 4 声明使用该插件,并且对齐进行配置

- Vue.use(VueLazyload, {
  loading
})


### 5 在对应需要使用图片懒加载的图片src属性更改为插件提供的指令 v-lazy

## 路由组件的懒加载

###  路由懒加载的作用

- 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样提高加载效率

### 1 在引入对应的路由组件的时候,使用另外一种方式引入

- const GroupBuy=()=>import('@/pages/Center/GroupBuy')

## 三级分类列表的优化

### 1 在对应的三级列表标签外套一层transition标签,并添加一个name属性

### 2 在对应的样式中书写对应的过渡动画的css样式


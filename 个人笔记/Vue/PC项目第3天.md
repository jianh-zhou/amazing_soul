# PC项目第3天

## 轮播图的小bug

### bug

- 1 在一个组件中引用对应的swiper模块和样式,另外一个兄弟组件不引入最终也能实现轮播图的效果

### bug原因

- swiper是在实例化之后才能才能让正常的轮播图实现轮播,而实例化时,第一个参数就是选择对应的轮播图的选择器,或者元素对象.而最开始复制粘贴过来时,选择器都是一样的,所有在一个组件中实例化,其他组件的轮播图也能实现效果

### 解决

- 1 可以给每一个需要使用的轮播图的组件,都进行实例swiper,修改swiper对应容器的属性值,虽然属性效果是一样的,但是这样会提高代码符可维护性
- 将都有使用的关于swiper的css都放在main.js中

## 轮播图组件

### 1 创建一个普通的轮播图组件

### 2 在main.js文件中引入该组件

### 3 在main.js中全局注册该组件

- Vue.component('Carousel',Carousel)

### 组件内容

- 1 复制对应的swiper标签模板,给外层盒子添加一个ref属性,属性值为rw

	- 添加该属性值,可以直接传入一个对象,而不是传入一个选择器

- 2 引入swiper

	- import Swiper from 'swiper'

- 3 利用watch监视得到传入的数据,

	- 1 添加一个immediate属性,并且属性值设置为true
	- 2 使用一个一个handler属性,属性值是一个回调函数,该回调函数中,调用一个this.$nextTick方法,该方法中执行实例swiper的操作,并且第一个参数传入一个对象,该对象是this.$refs.rw

## 楼层轮播图的大bug

### bug

- 对楼层轮播图进行遍历后,当前楼层轮播图失效

### bug原因

- 楼层组件是有两个的,我们是通过遍历得到的楼层组件,而对应的数据是异步请求的,在楼层组件渲染时,利用的是v-for遍历,而没有数据,则直接不遍历,对应组件里面的代码就不会执行
-     当异步请求数据完成之后并返回,数据更新,楼层组件会再此进行遍历,此时有数据了,楼层组件里面的代码就会执行,然后最执行对应的Carousel组件,而swiper实例是放在watch监视属性中,而watch触发的原因是监视的数据发生变化才会触发对应的代码,而楼层轮播图所对应的监视属性只进入了一次该组件,该属性值,并没有经历过变化,所有根本不会触发里面的实例swiper,所以最终轮播图也不会有效果

### bug解决

## 组件渲染的流程

### 组件在渲染过程中是先渲染子组件然后渲染父组件

### 代码是从上往下执行

### 如果对应的数据发生变化,组件会根据数据再次渲染,更新界面

### 组件之间传递的数据只要发生变化,可能就会引起页面的重新渲染

## 新的知识点

### immediate

- 是否要再侦听之后立即调用对应的handler回调函数
- true

	- 给对应监视属性添加一个属性,回调函数会侦听之后会直接执行,不管数据有没有变

- false

	- 默认值,表示数据发生变化会监听

### this.$nextTick(()=>{})

- 将回调延迟到下一轮DOM更新循环之后执行,在修改数据后立即使用它,然后等待DOM更新
- 该方法和Vue.nextTick一样,只是this只写不一样,$nextTick方法是当前的实例对象,

## 创建一个新的search组件的数据文件,作为一个module模块

### 1  封装一个api函数

- 设置对应的接口及

	- export const reqProductList=ajax.post('/list',searchParams)

### 2 在对应的module模块文件中引入该文件,并且最终调用该方法,返回数据

## 易错及注意

### 1 

### 子主题 2

### 子主题 3


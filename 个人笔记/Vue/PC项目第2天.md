# PC 项目第2天

## modules

### vuex中允许我们将store分为多个模块(module).每个模块都有自己的state,mutations,actions,getters,   modules就是多个模块的集合

### 作用

- 提高代码的可维护性
- 可以根据模块的不同,创建不同的module,方便数据状态的管理

### 使用流程

- 1 创建对应的modules文件夹,创键一个index文件,index文件用来暴露modules对象,该文件中引入对应的module
- 2 根据组件创建对应的module,该文件会暴露一个对象,该对象包括state,modules,getters,actions四个对象
- 3 在store文件夹下的index文件中,引入暴露moudles对象的文件,并且添加到store实例化时的配置对象上

### 使用vuex中的数据

- state

	- 1 引入辅助函数mapstate
	- 2 辅助函数传入一个对象,属性名为对应的状态数据名,属性值为一个回调函数,该回调函数传入一个state作为参数,根据state返回对应的数据

		- ...mapState({floors: state=>state.home.floors})

- 其他用法和之前一样

### 注意点

- 1 每一个module都是一个单独的文件,对应一个组件的数据状态的集合和操作
- 2 store文件夹中的数据在实例化的的配置对象属性,store,getters,mutations,actions它们是总的对象,
- 3 当总的actions和分的actions的方法名一样时,在分发时,这两个方法都会触发,总的actions方法会先触发,

## 函数的防抖和节流

### 节流

- 最开始会执行一次,然后在间隔的时间内不会怎么触发都不会执行,只有在大于这段间隔时间才会执行
- 应用场景

	- 窗口的应用
	- 页面的滚动
	- 拖拽的行为
	- 鼠标的进入和离开事件(疯狂抢购)

### 防抖

- 只会执行最后一次,不管怎么触发,只有当最后一次触发后,过一段时间才会执行
- 应用场景

	- 文本框输入内容验证操作(ajax请求)
	- 实时的联想搜索(键盘的抬起事件)

### 防抖和节流的使用流程

- 1 下载对应的包

	- npm install  lodash

- 2 引入对应的包

	- import _ from 'lodash '

		- 直接引入,浪费资源,

	- import throttle form 'lodash/throttle'

		- 按需引入

- 3 throttle使用

	- 定义一个方法,值为throttle( ),throttle方法传递一个回调函数作为参数和间隔时间

### 手写

- 节流

	- 1 给事件赋值为一个函数的直接调用,传入两个参数,一个是一个回调函数callback,一个是节流的间隔时间
	-  2 函数直接调用的内部,声明一个变量start,设置为初始时间值0,
	- 3 直接返回一个函数,利用...args传递参数,
	- 4 定义一个变量timeNow,保存当前的试时间戳, 函数内部判断timeNoe和start的差值是否大于传递进来的间隔时间,
	- 5 如果大于,则将最开始的start设置为timeNow 然后执行回调函数callback,并且需要使用apply改变this的指向,让其的this指向当前触发事件的对象

- 防抖

	- 1 传入对应的参数,返回一个函数
	- 2 判断当前传入的回调函数是否有定时器的句柄属性,如果有,则清除定时器,否则执行后面的代码
	- 3 添加一个定时器,并将定时器的句柄添加到传入参数的一个属性上,在定时器内部调用传入进来的回调函数,并且改变this指向

## 三级分列列表数据的遍历循环

### 1 分发对应的action,最终获得数据

### 2 通过v-for遍历对应的数据,最终展示在页面

### 3 在遍历时,注意数据的嵌套

##  三级分类列表的路由传参

###  直接对使用声明式路由,但是这样会造成对性能造成影响,因为v-for嵌套太深,

### 1 为每一个a标签添加两个动态的自定义属性,保存在路由传参时,需要的数据

### 2 使用事件委托,为父级元素绑定点击一个事件

### 3 通过事件对象判断当前元素是否是a标签,

- if(e.target.nodeName==='A')

### 4 在判断中通过解构赋值获取对应的自定义属性的参数对象

- 自定义属性对象: e.target.datatset
- 在解构赋值时,所有的属性都变为小写,就算书写的时候是大写,经过浏览器的解析,最终都会变为小写

### 5 直接使用编程式路由的方式实现路由跳转

- 1 使用query的方式进行传参,因为query的参数属性值不固定的,可以定义一个变量保存query对象
- 2 判断自定义属性的数据,最终给query对象添加一个该属性
- 3 this.$router.push('/search',query)

## 三级分类列表的高亮显示和三级分类列表的显示与隐藏

### 要求:

- 鼠标移入对应的列表,当前列表背景颜色发生变化,  并且实现非home界面,直接展示三级分类列表的数据

### 1 为三级分类列表的最外层绑定一个鼠标移入和鼠标移出事件

- 定义一个数据isShowFirst,设为最开始三级列表数据是否展示(true),
- 鼠标移入事件

	- 直接设置列表的初始数据值isShowFirst,设置为ture
	- 设置一个currentInde为任意值,只要不是设置为初始值-2即可

		- 如果不设置改值,那么高亮的条件就一直不好满足,只有设置这个值后,第一次才会进入判断,最终一直才会随着鼠标的移动高亮发生变化

- 鼠标移出事件

	- 判断当前的的路由地址是否为home组件的路由地址

		- if(this.$route,path!=='/)'
		- 如果满足条件,则设置isShowFirst为false
		- 直接设置高亮时的初始数据值为初始值-2

### 2 为相应的列表栏标签绑定一个鼠标移入事件

- 对应的列表是否高亮显示
-  定义一个数据currentIndex,设为最初始的一个下标值为-2
- 1 判断当前事件传递进来的回调函数是否为初始值-2,如果不是则将currentIndex设置为传递进来的参数
- 2 给列表标签设置一个动态class属性,值为一个对象,即是否当前下标值是否等于currentIndex.如果等于应用该样式,否则不应用,也就是是否高亮

### 3 执行一个生命周期回调函数mounted

- 1 判断当前路由地址是否不为'/'

	- 满足条件则让设置isShowFirst值为false

### bug

- 使用节流后,高亮显示可能会错误,最后当鼠标移出时,可能会停留在某一个列表上,出现bug
- 原因

	- 使用了节流,当鼠标移动过快的时候,节流传递的回调函数没有执行,但熟标移入的高亮事件被一直触发,到最后,就会卡在最后一个移出的列表栏里

- 解决方案

	- 在内存鼠标进入事件中加一个判断,就是判断当前的currentInde值是否为-2,如果不为-2,则不设置对应的下标,只要鼠标一移出,currentIndex设置的值为-2,后续的事件就不会再触发高亮显示,在外层鼠标进入时,设置一个currentIndex的值不为-2,让其能够进入内存的鼠标进入事件,否则不能进入,不能实现高亮

## mock

### 作用

- 拦截ajax请求,生成随机数据

### 使用

- 设计一点类似于后台的数据, 保存在json文件中,通过mock的方式拦截对应的请求的地址,并把数据返回

### 安装

- npm i mockjs

### 流程

- 1 设计后台数据
- 2 封装对应的api接口函数
- 3 引入对应的模板数据,然后利用Mock.mock方式进行拦截,

	- Mock.mock('/mock/banners',{ code:200 ,msg:'请求成功',data:banners}

- 4 将数据放在vuex中的模块中,方便管理和使用
- 5 最终通过分发action方法的,改变对应的数据状态,使用辅助函数得到对应的数据

## swiper轮播图

### 1 下载swiper对应的包,

- npm  install swiper@5.4.2

### 2 引入swiper

- import Swiper from 'swiper'

### 3  引入swiper需要使用到的样式,

- import 'swiper/css/swipre.csss'

### 4 引入对应的html模板

### 5 引入对应的script模板

## 注意以及错误

### 1 在使用v-for指令循环时,在标签上多加了一个 /

- 不能使用遍历后的数据,出现报错


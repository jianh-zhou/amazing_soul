# ES6重点及核心

## Iterator

### 解释

- 数据结构总共有多种,但我们对其进行迭代确很不方便,有的只能拿到键值,却不能直接拿到键名,在操作数据时会有很多局限
- Iterator是一个接口,只要数据结构上部署有该接口,就能遍历该数据结构中的数据
- 该方法可以直接拿到每一个属性的value值

### for in的不足

- 只能拿到对象的键名,不能直接拿到键值

### 有该接口的数据类型及数据结构

- 数组

	- 遍历其中所有对元素item

- set

	- 遍历所有的元素

- map

	- 遍历结果是一个个数组

- 字符串

	- 是字符串的每个值

### 对象是没有该接口的

### 应用

- ...扩展运算符
- for of遍历
- 使得数据结构能够按照某种次序排列

### for of 

- 原理

	- 通过查看数据能否可以调用Symbol.itetator方法
	- 通过调用该方法,对其进行迭代

## Generator函数

### 格式

- 例子

	- function* gen(){ }

- 在定义时在函数function后面加一个*

### 该函数提供了一种异步编程的解决方案,内部封装了很多状态,称之为状态机生成器

### 特征

- 在定义时function后面加*
- 里面有yelid表达式

### 该函数的返回值是一个iterator遍历器对象

### 该函数定义时,里面有一个yelid表达式,后面可以跟代码,每个遍历器对象(iterator)都会有next方法,通过调用next方法,运行该函数里面的代码,会运行一次yelid后面的代码,然后就会停在这里,通过每次调用next方法,可以执行完里面的所有代码,yelid后面的返回值就是next方法调用后的value值,done属性的值是根据是否迭代完来判断

### 在调用next方法时,传递的参数,作为yelid表达式的返回值

## async和await

### 格式

- 例子

	- async function gen(){ console.log('开始执行');              await console.log('我这里可以书写异步代码')}   gen( )
	- 利用async运算符

### 作用

- 解决异步编程

### await表达式后面跟的代码

- 正常数据

	- 直接执行,不会阻塞代码,不起任何作用

- Promise对象

	- 对象为成功状态

		- 会直接继续执行代码.直到结束.如果碰到初始化状态和失败状态就会执行它们状态的事情

	- 对象为失败状态

		- 直接退出当前ansyc语句

	- 对象为初始化状态

		- 会一直等待,直到变化为成功状态

- 该表达式的返回值

	- 失败或成功状态时resolve()和reject( )传递的参数
	- 其他则为undefined

### async函数

- 返回值就是一个Promise对象
- 状态由函数里面语句决定

	- 全部代码执行完毕状态为成功状态
	- 遇到reject状态,状态就为失败状态
	- pending状态,就为pening状态

### 语法糖,核心原理没有变

## Promise对象

### 产生方式

- const promise=new Promise((resolve,reject)=>{   })
- 通过实例化Promise构造函数
- 构造函数括号里面的,参数是一个回调函数
- 回调函数里有两个参数,第一个参数代表成功状态时调用,第二个代表失败时调用

### Promise对象的三种状态

- pending

	- 初始化状态

		- 默认状态

- resolve/fulfilled

	- 成功状态

- reject

	- 失败状态

### 作用

- 可以让异步代码以同步代码的形式表达出来,解决回调函数的层层嵌套问题( 回调地狱)

### then( )方法

- Promise对象状态为成功时,调用该方法
- 该方法里面可以写两个回调函数

	- 第一个回调函数代表Promise对象状态成功时执行
	- 第二个回调函数代表Promise对象状态失败时执行

- 一般只写一个回调函数作为参数,代表成功时调用的方法
- 调用该方法符返回值也是一个Promise对象,状态默认为成功状态

### catach( )方法

- Promise对象状态为失败时,调用该方法
- 该方法里面只可以写一个回调函数

	- 回调函数代表Promise对象状态失败时执行

- 调用该方法符返回值也是一个Promise对象,状态默认为成功状态

### 影响then( )和catch( )返回值状态的几种情况

- 回调函数参数返回值是Promise对象

	- resolve( )

		- 将当前方法的状态改为成功状态,方法的参数是下一个调用的参数

	- reject( )

		- 将当前方法的状态改为失败状态,方法的参数是下一个调用的参数

	- 没有resolve( )和reject()

		- 为初始化状态

- 回调函数参数抛出一个错误时

	- 方法返回值改为失败状态,并报错
	- 如果链式调用时,有catch接收,则不会报错

- 回调函数没有返回值或者返回值不为Promise对象时

	- 默认是成功状态

### finally( )

- 不管是成功还是失败状态,都会执行该方法里面的回调函数
- 初始化状态就不会执行该方法里面的回调函数

## Promise构造函数

### all( )

- 参数

	- 是一个数组,数组中的每一个元素为一个Promise对象

- 方法的返回值

	- 返回的也是一个Promise对象
	- 当数组中的所有参数都为成功状态时,则该返回值就为成功状态
	- 只要有一个为失败状态,该返回值就为失败状态

- 返回值调用then().catch( )方法,里面的回调函数参数值的情况

	- .then((sucess)=>{ } )

		- 该方法的参数值是一个数组,数组中的元素是调用all方法时里面的Promise对象中的resolve中传递的参数

	- .catch( (error )=>{ })

		- 该方法的参数值是是调用all方法时里面的Promise对象中的reject( )中传递的参数

### resolve( )

- 返回一个成功状态promise对象
- 里面可以传递一个promise对象,该参数就是该方法的最终状态

### reject( )

- 返回一个失败状态promise对象
- 不管参数传递的是什么,最终的返回的primise对象都为失败状态

### allSettlled( )

- 传入n个promise对象，等n个promise对象状态全部发生变化，得到所有结果值


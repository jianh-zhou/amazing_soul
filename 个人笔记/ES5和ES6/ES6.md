# ES6

## 数组扩展

### 扩展运算符

- 格式:  ...
- 把当前数组展开,变为一个用逗号分隔的参数序列

	- conset arr=[1,2,3,4]
	- console.log(...arr)---输出结果是,1,2,3,4

- 作用

	- 复制数组

		- let arr1=[...arr]
		- 这是直接复制,属于浅复制,并不是复制内存地址值

	- 解构赋值

		- ler [a,b,...newarr]=[1,2,4,4,5,6]

	- 字符串转数组

		- let arr2=[...'hello']

	- 合并数组

		- ler arr3=[...arr,...arr1]

	-  函数调用时传递一个数组或者字符串,为形参赋值

### Array 的新方法

- Array.from( )

	- 将伪数组转换为数组

- Array.of( )

	- 将一串用逗号隔开的数字转换为数组

### Array.prototype上的方法

-   copyWithin( )

	- 参数

		- 参数1(target)

			- 以该元素初始位置进行覆盖

		- 参数2(start)

			- 以这开始为要覆盖值的起始位置(包括当前位置)

		- 参数3(end)

			- 以这结束为要覆盖值的结束位置( 但不包含当前位置),如果没有则是起始位置后的全部

	- 返回值为一个数组,会改变原数组
	- 就是将第二个参数和第三个参数中间的值(不包括第二个值的位置)以参数1的位置开始覆盖,值有多少就覆盖多少

- flat( )

	- 参数

		- 没有参数
		- 参数只能为整数时

	- 功能

		- 可以将数组进行铺开,就是把多维数组展开为一定维度的数组

	- 返回值

		- 是一个数组,但不改变原数组

- fill()

	- 参数

		- 参数1

			- 要替换的元素

		- 参数2 

			- 替换的开始的位置,包括起始位置

		- 参数3

			- 替换结束的位置,但不包括结束

		- 只有第一个参数时,默认全部替换

	- 功能

		- 替换数组中的元素,可以指定替换的位置和数量

	- 返回值

		- 改变原数组,返回改变后的数组 

- find()

	- 参数

		- 一个回调函数

	- 功能

		- 会遍历数组,如果该次回调函数中返回true,则该次数组中的元素作为该次方法的返回值

	- 返回值

		- 回调函数返回值值true时,当前次的元素就是该方法的返回值

- findindex

	- 参数

		- 一个回调函数

	- 功能

		- 会遍历数组,会返回数组中对一次函数返回值为true数组元素的下标

- entries( )

	- 返回一个遍历器对象,可以通过for of遍历该遍历器对象,返回一个个键值对

- keys( )

	- 返回一个遍历器对象,可以通过for of遍历该遍历器对象,返回一个个键名

- values( )

	- 返回一个遍历器对象,可以通过for of遍历该遍历器对象,返回一个个键值

- includes( )

	- 检查数组中是否含有某个元素,如果有则返回true,否则返回false

## 函数扩展

### 为函数参数设置默认值

- 直接在对应参数位置设置形参等于对应值
- 如果有传递实参则用实参,否则就用设置的默认值

### rest参数

- 格式为...rest
- 它的返回值一个数组,就是实参组成的数组
- 可以替代arguments ,因为箭头函数中没有arguments
- 该参数必须放在形参的最后面

### 箭头函数

- 语法

	- ( )=>{ }
	- 没有形参和实参为两个或两个以上时必须写括号
	- 函数体只有一句话时,可以省略大括号,如果是return语句,可以省略return
	- 只有一个实参时,可以不写括号

- this指向

	- 没有自己的this指向
	- 是在定义时指向的对象

- 注意点

	- 不能用于构造函数,不能new关键字使用
	- 函数不能使用yeild命令,不能书写Generator函数
	- 没有arguments

## 对象扩展

### 对象简写

- 方法简写

	- 省略中间的 : 和function

- 属性简写

	- 当属性名和属性值一样时,可以只写一个,这里的value是一个变量名时,看着和key一样

### 属性名表达式

- 解决属性名只能写字符串
- 可以在属性名加一个[ ],里面可以加任何数据,最终都会转换为字符串

### 扩展运算符

- let obj={a;1,b:2,c:3,d:4}  let {a,b,...e}=obj

	- console.log(a,b,e)

		- 1  , 2 ,  {c:3,d:4}

### 方法

- Object.is( obj1,obj2)

	- 比较两个对象,相当于===
	- 返回一个布尔值

- Object.assign(obj1,obj2)

	- 合并对象.里面可以传递多个对象
	- 全部合并到第一个对象中
	- 返回一个新对象,是对第一个对象的引用

## Symbol 数据类型

### 语法

- const sm=Symbol('我是独一无二的一个值')
- 里面可以跟一个参数,但他没有任何实质性的作用,只是一个标识符,让我们可以区分它们

### 作用

- 当我们要对一个未知对象添加一个属性时,我们添加的属性就有可能改变原来对象里面的属性,所以我们需要有一个独一无二的属性名,来给对象添加属性
- 在添加属性时,我们需要利用一个变量把Symbol数据类型的值赋值给该变量,否则就取不到该属性,因为每一个Symbol类型的值都不一样

### 是一种基本数据类型

### 该值的类型转换

- 转换为布尔值

	- true

- 转换为字符串

	- 'Symbol()'

- 转换为数值

	- 报错

## Bigint 数据类型

### 它就是一种基本数据类型

### 在数字后面加上字母n就表示该数据为Bigint数据类型

### 作用

- 解决数据过大运算时的不准确性
- 正常数值类型在大于2**54时,计算就变的不准确了.会出现误差.在超过2**1024时计算的数值就为Infinity,在数值过大时,采用的是科学计数法,小数位是有限的,所以会出现误差
- 该数据类型只有在针对整数时,计算才会有效果,而不会产生误差,但是数值过大的话,则会出现报错的情况

### 它与不加n的数值在进行相等比较时,返回true,全等时返回false

## Set数据结构

### 语法

- const set=new Set([1,2,3,4,5,6,2])
- 他会去掉参数里面重复的值

### 该数据结构类似于数组 

### 作用

- 数组去重

### 可以传递的参数

- 数据具有Iterator接口的数据

	- 数组
	- 字符串
	- 伪数组

### 属性及方法

- size属性

	- 返回set数据结构的长度,类似于数组的length

- add( )

	- 为该数组结构添加元素

- delete( )

	- 删除其中的一个元素,如果成功返回true,否则返回false

- has( )

	- 判断是否有某元素,返回一个布尔值

- keys( )

	- 返回每个值的键名

- values( )

	- 返回每个值的键值

- entries( )

	- 返回一个键名与键值对应的集合

- forEach 

	- 回调函数里面的item和index相等,一一对应

## Map数据结构

### 语法

- const map=new Map([ [ { } , 1 ] , [ a , 2 ] ])

### 作用

- 解决对象属性值只能为最终都只是字符串的情况
- 里面的元素值可以是任何数据类型
- 让其真正的达到键值对的情况,键和值都可以为任意数据类型

### 属性及方法

- size属性

	- 返回Map数据结构的键值对数量

- set( )

	-   map1.set("age",19)
	- 如果机构中有该属性,则会覆盖,否则就是添加

- get( )

	- 读取结构中对应的键值,如果没有则返回indefined

- delete( )

	- 删除其中的一个元素,如果成功返回true,否则返回false

- has( )

	- 判断是否有某元素,返回一个布尔值

- keys( )

	- 返回每个值的键名

- values( )

	- 返回每个值的键值

- entries( )

	- 返回一个键名与键值对应的集合

- forEach 

	- 回调函数里面的item和index相等,一一对应

- clear( )

	- 清除数据结构中的所有成员

## 类(class)

### 语法

- class  Animal{  constructor(name,age){  
 this.age=age ; this.name=name;}         
 say(){ console.log('我是一个类')}   }

### 注意点

- 必须得有一个constructor函数
- 直接里面添加的方法就是该类的Prototype上面的方法
- 直接在里面添加的属性就是实例化对象的属性
- 如果要给自己加属性或者方法,则需要用一个表达式static ,后面跟需要加的方法或者属性

### 书写继承

- 语法

	- class Person extends Animal {  
  constructor(name,age,sex){ super(name,age);  this.sex=sex}; read( ){ console.log('我是继承')}}  

- 注意点

	- 要在contructor函数中加一个super( )方法,原理就是this的指向问题


# 7.11 js 第八天

## contructor 属性

##### 每次生成一个对象时,会在生成对象的里面储存 contructor 属性,该属性是一个指针,指向生成这个对象的构造函数

##### 构造函数的原型对象中,会存储该属性,它指向的是拥有该原型对象的构造函数

## 原型链

##### 核心思想

构造函数的 prototype 属性它是一个对象,该对象是 obiect 构造函数生成的,他也是实例对象,也有\_\_proto\_\_属性,会指向生成自身函数的 prototype 属性; 而利用构造函数生成的对象,它有一个\_\_proto\_\_属性指向的是构造函数的原型对象,而该原型对象也是一个实例对象,也有一个\_\_proto\_\_,它会指向生成该实例对象 prototype 属性对象,这时 object 函数的 prototype 属性对象里面的\_\_proto\_\_为 null,不继续往下寻找

##### 沿着实例一直找属性,终点是 object 函数的 prototype 属性对象,

##### 实例对象自身 ----> 自身**proto**属性指向的构造函数的原型对象 ----> 构造函数原型对象中**proto**指向的生成 object 对象的 object 函数的 prototype 属性对象,

## return 的返回情况

##### 正常函数

- 有 return,但没有返回值,最终的结果是 undefined
- 有 return,有返回值,结果就是返回值

##### 构造函数

- 当返回值是基本数据类型时,返回的结果是实例对象
- 当返回值是对象时,返回的结果就是返回值一个对象
- 有 return,但没返回值时,返回的就是实例对象

## prototype 属性

##### 每个函数都有一个 prototype 属性,当函数是构造函数时,才会有 prototype 属性

##### 在构造函数中,prototype 是构造函数的属性,它也是一个对象

##### prototype 对象可以存储所有实例对象的一些属性和方法

## \_\_proto\_\_属性

##### 每个有构造函数实例出来的对象,都会有**proto**属性,该属性的值是构造函数的原型对象的存储地址

##### 在实例对象寻找属性方法的过程,就是沿着该属性一直寻找,如果自身没有,去原型对象中寻找,原型对象中也没有,就去原型的原型对象中寻找

## 原型的分类

##### 显示原型

- 就是构造函数中的 Prototype 属性

##### 隐式原型

- 实例对象的**proto**属性

## instanceof

##### 用法

- 实例对象 instanceof 构造函数的名字(XX 类)
- 实例对象是否是 xx 类型,返回结果是 true 或者 false

##### 检查规则

- 沿着实例对象的**proto**属性寻找 .沿着构造函数的 prototype 寻找,如果最终他们能找到同一个对象,那么就说明实例对象就是属于某一类的,返回的结果是 true

## this

#### 全局中的 this 就是 window

##### 函数调用如果是光秃秃的,就是只是一个函数的调用,那么 this 也就是 window

##### 如果是调用的某个对象的方法,那么 this 就是该对象

## 改变 this

##### call

- call( thisArg , arg1 , arg2..... )
- 后面是跟的传的实参,

##### apply

- apply(thisArg , [arg1Array])
- 后面是跟的传的实参,以数组的形式

##### 每个函数都有函数和方法,它们最大的区别就是 call 后面是属性,apply 是一个数组

## new 操作符的流程

##### 1 对象开辟一个空间

##### 2 设置原型链

##### 3 将构造函数里的 this 指向自己

##### 4 执行函数代码

##### 5 将创建对象以实例返回

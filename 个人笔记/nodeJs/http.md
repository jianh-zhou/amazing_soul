# http

## http模块

### 引用

- 该模块在使用时需要利用require( ) 来引入该模块

### 功能

- 作为客户端

	- 发送请求
	- 接收响应

- 作为服务器

	- 可以接收请求,
	- 发送响应

## 服务器的搭建

### 1 引入http模块

- const http=require('http')

### 2 创建一个服务

- const res=http.createSever((request , reponse)=>{  
 response.setHeader('content-type'," 'txt/html';charst="utf-8);    response.end('这是我的第一个服务器')};                                            

### 3 设置主机地址和域名

- const port=1212;  const  host='localhost'; 

### 4启动服务

- res.listen( port,host,(err)=>{ if(err){console.log('服务器创建失败')};console.log('服务器创建成功' ) }  

### 本地主机端口号

- localhost
- 127.0.0.1

## 客户端的搭建

### 1 引入 http 模块

- const http=require('http')

### 2 将URL地址保存为一个变量

- const url ="http://localhost:1212";

### 3 书写请求

- const request=http.request(url,(res)=>{   res.on('data',(chuck)=>{ console.log(chuck.toString( ))}
- 获得的chuck数据时Buffer数据,我们可以用拼串的思想来将其转换为字符串

### 4 发送请求 

- requset.end( )

## http 协议

### http协议即超文本传输协议  Hyper Text Transfer Protocol

### 它是规定两台计算机之间进行通信是所遵循的一个规范,所有www文件必须遵守该协议

### 该协议其实是规定报文的格式

### 报文

- 网络通信之间的内容我们称之为报文
- 请求报文

	- 客户端发送给服务端的内容

- 响应报文

	- 服务端响应给客户端的内容

## http 报文

### 报文的含义

- 它是HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文都是在客户端、服务器和代理之间流动。

### 报文的流动方向

- 一次报文,它会产从客服端-->代理端--.服务器, 在服务器工作完成之后,会从服务器-->代理端-->客户端

## 请求方式

### GET 查

- 请求页面的指定信息,并返回实体
- 随着 URL请求地址发生( 查询字符串)

### POST  增

- 向指定的资源提交数据进行处理
- 数据会在在报文的报文题中发送

### PUT 改

- 更改服务器数据

### DELETE  删

- 删除指定数据

## 常见的MIME 类型

### text/plain

- 文本文件

### text/html

- html 文件

### text/css

- css 文件

### image./jpg

- 格式为jpg的图片

### image./jpeg

- 格式为jpge的图片

### image./png

- 格式为png的图片

### image./gif

- 格式为gif的图片

### image./webp

- 格式为jpg的图片

### video/mp4

- mp4 文件

### autio/mp3

- mp3 文件

### allipaction/javascript

- js文件

### allipaction/json

- json 文件

### application/x-www-form-urlencoded form

- 表单

## 响应状态码

### 1xx

- 正在处理请求中

	- 100

		- 一切正常,正在请求

	- 101

		- 正在切换协议

### 2xx

- 请求成功

	- 200

		- 请求成功

	- 204

		- PUT和DELETE一般发生204,表示页面没有发生修改

### 3xx

- 重定向

	- 301

		- 永久重定向

	- 302

		- 暂时重定向

	- 304

		- 读取缓存(协商缓存)

### 4xx

- 客户端错误

	- 400

		- 代表响应报文有问题,需要修改

	- 403

		- 服务器拒绝访问

	- 404

		- 服务端无法找到服务的资源,或者不想给出响应

### 5xx

- 服务端错误

	- 500

		- 代表服务端在执行客户端请求时出现错误

	- 503

		- 代表服务器超负荷或者维护停机中.无法处理响应

## OSI参考层模型的划分

### 应用层

- 最接近用户的一层,为计算机提供应用接口,也为用户提供各种网络服务
- 常见的应用层网络服务协议

	- HTTP
	- HTTPS
	- FTP
	- POT3
	- SMTP

### 表示层

- 提供应用层数据的编码和转换功能,确保一个应用层发送的数据能被另一个系统的应用层识别 
- 如果有必要,可以采用一种标准表示形式,将计算机中的多种数据采用这种形式表达

### 会话层

- 负责建立.管理和终止表示层实体之间的会话  
- 该层的通信由不同设备中的应用程序之间的服务请求和响应组成

### 传输层

- 传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路,我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”

### 网络层

- 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础

### 数据链接层

- 数据链路可以粗略地理解为数据通道。物理层要为终端设备间的数据通信提供传输媒体及其连接.媒体是长期的,连接是有生存期的.在连接生存期内,收发两端可以进行不等的一次或多次数据通信.每次通信都要经过建立通信联络和拆除通信联络两过程.这种建立起来的数据收发关系就叫作数据链路。并进行差错检测

### 物理层

- 实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。

## 输入URL到网页渲染

### 1 DNS 查询

- 输入的是域名,需要DNS 查询,获得ip地址
- 4次查询,1次递归

	- 浏览器DNS 查询
	- 计算机DNS 查询
	- 路由器DNS 查询
	- 运营商DNS 查询
	- a.com b.a.com c.b.a.com

### 2 TCP连接:TCP3次握手

-  第一次握手

	- 浏览器发给服务端,准备发送请求

- 第二次握手

	- 服务端接收请求后,给浏览器响应,能够接收请求

- 第三次握手

	- 浏览器再给服务端发送,收到服务器的信息

- 三次握手的原因

	- 第一次发送出去后,服务器接收到请求,服务端是知道浏览器能发送请求,自己能接收请求.第二次服务端响应后,浏览器知道自己能够发送和接收,但服务端只知道自己能收到请求,这时第三次握手,服务端收到后,就知道自己能发送和接收请求
	- 能够确定自己或者对方能够接收和发送请求

### 3 发送请求

- 按照http协议,生成请求报文,将其发送给服务器

### 4 返回响应

- 按照http协议,生成响应报文,将其发送给浏览器

### 5 渲染页面

- 1 根据html绘制DOM tree
- 2 根据css绘制CSSOM tree
- 3 将DOM tree 和CSSOM tree 合并为 render tree (渲染树)
- 4  分层( 根据层叠上下文分层)
- 5 生成图层绘制指令
- 7 栅格化 ,将图层分为图块
- 8 合成与显示,最终绘制过程

### 6 断开连接,TCP4次挥手

- 第一次挥手

	- 浏览器告诉服务器,请求报文发送完毕

- 第二次挥手

	- 服务器告诉浏览器,请求报文接收完毕,浏览器可以等待断开

- 第三次挥手 

	- 服务器告诉浏览器,响应报文发送完毕

- 第四次挥手

	- 浏览器告诉服务器,响应报文接收完毕,可以断开连接

## 浏览器渲染

### 1 构建DOM树

- 输入

	- html

- 输出

	- DOM树

- 操作过程

	- 将html转为为浏览器能认识的DOM树,在此期间,会去下载一些次级资源,及执行一些js代码

### 2 样式计算

- 转换为浏览器可以认识的stylesheets数据结构
- 将css转换为标准的样式

	- 比如rem转换为排序,blue转换为rgba

- 计算每个节点的样式

	- 涉及到一些属性的继承,样式的覆盖,层叠的规则

### 3 布局阶段

- 合成布局树

	- 布局树和DOM树结构类似,结构上只包括会显示节点的内容
	- 不包含display:none样式的元素

		- 该属性隐藏的是不可见的

-  计算节点位置

	- 主线程会计算出每个元素的位置信息和盒子大小

### 4  分层( 根据层叠上下文分层)

- 因为页面有很多复杂结构,比如滑动.z-index;为了更好的实现这些效果,渲染引擎主线程为特定的阶段生成专用的图层,并生成一个专门的图层树
- 拥有层叠上下文属性的元素会单独生成一个图层。

	- 3D 或透视变换的 css 属性
	- 使用加速视频解码的 video 元素
	- canvas 元素
	- opacity 属性

- 需要裁剪的地方也会单独生成一个图层

	- 裁剪就是需要滚动的地方，里面内容会单独生成一个图层。如果有滚动条，滚动条也会单独生成一个图层

### 5 生成图层绘制指令

- 在得到完整的图层树后,渲染引擎主线程会对每个图层进行绘制,但并不是真正的绘制页面,而是生成绘制指令列表

### 7 栅格化 ,

- 绘制指令生成之后，渲染进程主线程会将绘制指令发送给合成线程，由合成线程来完成最后的绘制工作。合成线程会将图层划分为图块

### 8 合成与显示,最终绘制过程

- 等所有图块都被栅格化，合成线程会收集位图信息来创建合成帧。合成帧随后会通过 IPC 协议将消息传给浏览器主进程。浏览器主进程收到消息后，会将页面内容绘制到内存中，最后再将内存显示在屏幕上。

